#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Blur::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Blur::Blur_listInstalledCommands_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listInstalledCommands_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listInstalledCommands_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_listInstalledCommands_result;
use base qw(Class::Accessor);
Blur::Blur_listInstalledCommands_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listInstalledCommands_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size258 = 0;
          $self->{success} = [];
          my $_etype261 = 0;
          $xfer += $input->readListBegin(\$_etype261, \$_size258);
          for (my $_i262 = 0; $_i262 < $_size258; ++$_i262)
          {
            my $elem263 = undef;
            $elem263 = new Blur::CommandDescriptor();
            $xfer += $elem263->read($input);
            push(@{$self->{success}},$elem263);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listInstalledCommands_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter264 (@{$self->{success}}) 
        {
          $xfer += ${iter264}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_execute_args;
use base qw(Class::Accessor);
Blur::Blur_execute_args->mk_accessors( qw( commandName arguments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{commandName} = undef;
  $self->{arguments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{commandName}) {
      $self->{commandName} = $vals->{commandName};
    }
    if (defined $vals->{arguments}) {
      $self->{arguments} = $vals->{arguments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_execute_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{commandName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{arguments} = new Blur::Arguments();
        $xfer += $self->{arguments}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_execute_args');
  if (defined $self->{commandName}) {
    $xfer += $output->writeFieldBegin('commandName', TType::STRING, 1);
    $xfer += $output->writeString($self->{commandName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arguments}) {
    $xfer += $output->writeFieldBegin('arguments', TType::STRUCT, 2);
    $xfer += $self->{arguments}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_execute_result;
use base qw(Class::Accessor);
Blur::Blur_execute_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{bex} = undef;
  $self->{tex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{bex}) {
      $self->{bex} = $vals->{bex};
    }
    if (defined $vals->{tex}) {
      $self->{tex} = $vals->{tex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_execute_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Response();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{bex} = new Blur::BlurException();
        $xfer += $self->{bex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tex} = new Blur::TimeoutException();
        $xfer += $self->{tex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_execute_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bex}) {
    $xfer += $output->writeFieldBegin('bex', TType::STRUCT, 1);
    $xfer += $self->{bex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tex}) {
    $xfer += $output->writeFieldBegin('tex', TType::STRUCT, 2);
    $xfer += $self->{tex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_reconnect_args;
use base qw(Class::Accessor);
Blur::Blur_reconnect_args->mk_accessors( qw( instanceExecutionId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{instanceExecutionId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{instanceExecutionId}) {
      $self->{instanceExecutionId} = $vals->{instanceExecutionId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_reconnect_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{instanceExecutionId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_reconnect_args');
  if (defined $self->{instanceExecutionId}) {
    $xfer += $output->writeFieldBegin('instanceExecutionId', TType::I64, 1);
    $xfer += $output->writeI64($self->{instanceExecutionId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_reconnect_result;
use base qw(Class::Accessor);
Blur::Blur_reconnect_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{bex} = undef;
  $self->{tex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{bex}) {
      $self->{bex} = $vals->{bex};
    }
    if (defined $vals->{tex}) {
      $self->{tex} = $vals->{tex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_reconnect_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Response();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{bex} = new Blur::BlurException();
        $xfer += $self->{bex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tex} = new Blur::TimeoutException();
        $xfer += $self->{tex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_reconnect_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bex}) {
    $xfer += $output->writeFieldBegin('bex', TType::STRUCT, 1);
    $xfer += $self->{bex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tex}) {
    $xfer += $output->writeFieldBegin('tex', TType::STRUCT, 2);
    $xfer += $self->{tex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandStatusList_args;
use base qw(Class::Accessor);
Blur::Blur_commandStatusList_args->mk_accessors( qw( startingAt fetch state ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startingAt} = undef;
  $self->{fetch} = undef;
  $self->{state} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startingAt}) {
      $self->{startingAt} = $vals->{startingAt};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandStatusList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startingAt});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandStatusList_args');
  if (defined $self->{startingAt}) {
    $xfer += $output->writeFieldBegin('startingAt', TType::I32, 1);
    $xfer += $output->writeI32($self->{startingAt});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I16, 2);
    $xfer += $output->writeI16($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 3);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandStatusList_result;
use base qw(Class::Accessor);
Blur::Blur_commandStatusList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandStatusList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size265 = 0;
          $self->{success} = [];
          my $_etype268 = 0;
          $xfer += $input->readListBegin(\$_etype268, \$_size265);
          for (my $_i269 = 0; $_i269 < $_size265; ++$_i269)
          {
            my $elem270 = undef;
            $xfer += $input->readString(\$elem270);
            push(@{$self->{success}},$elem270);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandStatusList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter271 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter271);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandStatus_args;
use base qw(Class::Accessor);
Blur::Blur_commandStatus_args->mk_accessors( qw( commandExecutionId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{commandExecutionId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{commandExecutionId}) {
      $self->{commandExecutionId} = $vals->{commandExecutionId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandStatus_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{commandExecutionId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandStatus_args');
  if (defined $self->{commandExecutionId}) {
    $xfer += $output->writeFieldBegin('commandExecutionId', TType::STRING, 1);
    $xfer += $output->writeString($self->{commandExecutionId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandStatus_result;
use base qw(Class::Accessor);
Blur::Blur_commandStatus_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandStatus_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::CommandStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandStatus_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandCancel_args;
use base qw(Class::Accessor);
Blur::Blur_commandCancel_args->mk_accessors( qw( commandExecutionId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{commandExecutionId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{commandExecutionId}) {
      $self->{commandExecutionId} = $vals->{commandExecutionId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandCancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{commandExecutionId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandCancel_args');
  if (defined $self->{commandExecutionId}) {
    $xfer += $output->writeFieldBegin('commandExecutionId', TType::STRING, 1);
    $xfer += $output->writeString($self->{commandExecutionId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_commandCancel_result;
use base qw(Class::Accessor);
Blur::Blur_commandCancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_commandCancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_commandCancel_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_refresh_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_refresh_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_refresh_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_refresh_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_refresh_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_refresh_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_args;
use base qw(Class::Accessor);
Blur::Blur_createTable_args->mk_accessors( qw( tableDescriptor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableDescriptor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableDescriptor}) {
      $self->{tableDescriptor} = $vals->{tableDescriptor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tableDescriptor} = new Blur::TableDescriptor();
        $xfer += $self->{tableDescriptor}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_args');
  if (defined $self->{tableDescriptor}) {
    $xfer += $output->writeFieldBegin('tableDescriptor', TType::STRUCT, 1);
    $xfer += $self->{tableDescriptor}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_result;
use base qw(Class::Accessor);
Blur::Blur_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_args;
use base qw(Class::Accessor);
Blur::Blur_enableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_result;
use base qw(Class::Accessor);
Blur::Blur_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_args;
use base qw(Class::Accessor);
Blur::Blur_disableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_result;
use base qw(Class::Accessor);
Blur::Blur_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_args;
use base qw(Class::Accessor);
Blur::Blur_removeTable_args->mk_accessors( qw( table deleteIndexFiles ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deleteIndexFiles} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deleteIndexFiles}) {
      $self->{deleteIndexFiles} = $vals->{deleteIndexFiles};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteIndexFiles});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteIndexFiles}) {
    $xfer += $output->writeFieldBegin('deleteIndexFiles', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteIndexFiles});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_result;
use base qw(Class::Accessor);
Blur::Blur_removeTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_args;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_args->mk_accessors( qw( table columnDefinition ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnDefinition} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnDefinition}) {
      $self->{columnDefinition} = $vals->{columnDefinition};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{columnDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{columnDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinition}) {
    $xfer += $output->writeFieldBegin('columnDefinition', TType::STRUCT, 2);
    $xfer += $self->{columnDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_result;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_result;
use base qw(Class::Accessor);
Blur::Blur_tableList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size272 = 0;
          $self->{success} = [];
          my $_etype275 = 0;
          $xfer += $input->readListBegin(\$_etype275, \$_size272);
          for (my $_i276 = 0; $_i276 < $_size272; ++$_i276)
          {
            my $elem277 = undef;
            $xfer += $input->readString(\$elem277);
            push(@{$self->{success}},$elem277);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter278 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter278);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_args;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_result;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size279 = 0;
          $self->{success} = [];
          my $_etype282 = 0;
          $xfer += $input->readListBegin(\$_etype282, \$_size279);
          for (my $_i283 = 0; $_i283 < $_size279; ++$_i283)
          {
            my $elem284 = undef;
            $xfer += $input->readString(\$elem284);
            push(@{$self->{success}},$elem284);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter285 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter285);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_args;
use base qw(Class::Accessor);
Blur::Blur_describe_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_result;
use base qw(Class::Accessor);
Blur::Blur_describe_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableDescriptor();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_args;
use base qw(Class::Accessor);
Blur::Blur_schema_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_result;
use base qw(Class::Accessor);
Blur::Blur_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_args;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_args->mk_accessors( qw( table query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::Query();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 2);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_result;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_args;
use base qw(Class::Accessor);
Blur::Blur_tableStats_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_result;
use base qw(Class::Accessor);
Blur::Blur_tableStats_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableStats();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_args;
use base qw(Class::Accessor);
Blur::Blur_optimize_args->mk_accessors( qw( table numberOfSegmentsPerShard ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{numberOfSegmentsPerShard} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{numberOfSegmentsPerShard}) {
      $self->{numberOfSegmentsPerShard} = $vals->{numberOfSegmentsPerShard};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numberOfSegmentsPerShard});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numberOfSegmentsPerShard}) {
    $xfer += $output->writeFieldBegin('numberOfSegmentsPerShard', TType::I32, 2);
    $xfer += $output->writeI32($self->{numberOfSegmentsPerShard});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_result;
use base qw(Class::Accessor);
Blur::Blur_optimize_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createSnapshot_args;
use base qw(Class::Accessor);
Blur::Blur_createSnapshot_args->mk_accessors( qw( table name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createSnapshot_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createSnapshot_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createSnapshot_result;
use base qw(Class::Accessor);
Blur::Blur_createSnapshot_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createSnapshot_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createSnapshot_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeSnapshot_args;
use base qw(Class::Accessor);
Blur::Blur_removeSnapshot_args->mk_accessors( qw( table name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeSnapshot_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeSnapshot_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeSnapshot_result;
use base qw(Class::Accessor);
Blur::Blur_removeSnapshot_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeSnapshot_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeSnapshot_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_listSnapshots_args;
use base qw(Class::Accessor);
Blur::Blur_listSnapshots_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listSnapshots_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listSnapshots_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_listSnapshots_result;
use base qw(Class::Accessor);
Blur::Blur_listSnapshots_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_listSnapshots_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size286 = 0;
          $self->{success} = {};
          my $_ktype287 = 0;
          my $_vtype288 = 0;
          $xfer += $input->readMapBegin(\$_ktype287, \$_vtype288, \$_size286);
          for (my $_i290 = 0; $_i290 < $_size286; ++$_i290)
          {
            my $key291 = '';
            my $val292 = [];
            $xfer += $input->readString(\$key291);
            {
              my $_size293 = 0;
              $val292 = [];
              my $_etype296 = 0;
              $xfer += $input->readListBegin(\$_etype296, \$_size293);
              for (my $_i297 = 0; $_i297 < $_size293; ++$_i297)
              {
                my $elem298 = undef;
                $xfer += $input->readString(\$elem298);
                push(@{$val292},$elem298);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key291} = $val292;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_listSnapshots_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter299,$viter300) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter299);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter300}}));
            {
              foreach my $iter301 (@{${viter300}}) 
              {
                $xfer += $output->writeString($iter301);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_setUser_args;
use base qw(Class::Accessor);
Blur::Blur_setUser_args->mk_accessors( qw( user ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{user} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{user}) {
      $self->{user} = $vals->{user};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_setUser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{user} = new Blur::User();
        $xfer += $self->{user}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_setUser_args');
  if (defined $self->{user}) {
    $xfer += $output->writeFieldBegin('user', TType::STRUCT, 1);
    $xfer += $self->{user}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_setUser_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_setUser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_setUser_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_args;
use base qw(Class::Accessor);
Blur::Blur_query_args->mk_accessors( qw( table blurQuery ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{blurQuery} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{blurQuery}) {
      $self->{blurQuery} = $vals->{blurQuery};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{blurQuery} = new Blur::BlurQuery();
        $xfer += $self->{blurQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blurQuery}) {
    $xfer += $output->writeFieldBegin('blurQuery', TType::STRUCT, 2);
    $xfer += $self->{blurQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_result;
use base qw(Class::Accessor);
Blur::Blur_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurResults();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_args->mk_accessors( qw( table selector ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selector} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 2);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::FetchResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRowBatch_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRowBatch_args->mk_accessors( qw( table selectors ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selectors} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selectors}) {
      $self->{selectors} = $vals->{selectors};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRowBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size302 = 0;
          $self->{selectors} = [];
          my $_etype305 = 0;
          $xfer += $input->readListBegin(\$_etype305, \$_size302);
          for (my $_i306 = 0; $_i306 < $_size302; ++$_i306)
          {
            my $elem307 = undef;
            $elem307 = new Blur::Selector();
            $xfer += $elem307->read($input);
            push(@{$self->{selectors}},$elem307);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRowBatch_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selectors}) {
    $xfer += $output->writeFieldBegin('selectors', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{selectors}}));
      {
        foreach my $iter308 (@{$self->{selectors}}) 
        {
          $xfer += ${iter308}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRowBatch_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRowBatch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRowBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size309 = 0;
          $self->{success} = [];
          my $_etype312 = 0;
          $xfer += $input->readListBegin(\$_etype312, \$_size309);
          for (my $_i313 = 0; $_i313 < $_size309; ++$_i313)
          {
            my $elem314 = undef;
            $elem314 = new Blur::FetchResult();
            $xfer += $elem314->read($input);
            push(@{$self->{success}},$elem314);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRowBatch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter315 (@{$self->{success}}) 
        {
          $xfer += ${iter315}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_loadData_args;
use base qw(Class::Accessor);
Blur::Blur_loadData_args->mk_accessors( qw( table location ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{location} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{location}) {
      $self->{location} = $vals->{location};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_loadData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{location});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_loadData_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{location}) {
    $xfer += $output->writeFieldBegin('location', TType::STRING, 2);
    $xfer += $output->writeString($self->{location});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_loadData_result;
use base qw(Class::Accessor);
Blur::Blur_loadData_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_loadData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_loadData_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_validateIndex_args;
use base qw(Class::Accessor);
Blur::Blur_validateIndex_args->mk_accessors( qw( table externalIndexPaths ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{externalIndexPaths} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{externalIndexPaths}) {
      $self->{externalIndexPaths} = $vals->{externalIndexPaths};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_validateIndex_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size316 = 0;
          $self->{externalIndexPaths} = [];
          my $_etype319 = 0;
          $xfer += $input->readListBegin(\$_etype319, \$_size316);
          for (my $_i320 = 0; $_i320 < $_size316; ++$_i320)
          {
            my $elem321 = undef;
            $xfer += $input->readString(\$elem321);
            push(@{$self->{externalIndexPaths}},$elem321);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_validateIndex_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{externalIndexPaths}) {
    $xfer += $output->writeFieldBegin('externalIndexPaths', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{externalIndexPaths}}));
      {
        foreach my $iter322 (@{$self->{externalIndexPaths}}) 
        {
          $xfer += $output->writeString($iter322);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_validateIndex_result;
use base qw(Class::Accessor);
Blur::Blur_validateIndex_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_validateIndex_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_validateIndex_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_loadIndex_args;
use base qw(Class::Accessor);
Blur::Blur_loadIndex_args->mk_accessors( qw( table externalIndexPaths ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{externalIndexPaths} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{externalIndexPaths}) {
      $self->{externalIndexPaths} = $vals->{externalIndexPaths};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_loadIndex_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size323 = 0;
          $self->{externalIndexPaths} = [];
          my $_etype326 = 0;
          $xfer += $input->readListBegin(\$_etype326, \$_size323);
          for (my $_i327 = 0; $_i327 < $_size323; ++$_i327)
          {
            my $elem328 = undef;
            $xfer += $input->readString(\$elem328);
            push(@{$self->{externalIndexPaths}},$elem328);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_loadIndex_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{externalIndexPaths}) {
    $xfer += $output->writeFieldBegin('externalIndexPaths', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{externalIndexPaths}}));
      {
        foreach my $iter329 (@{$self->{externalIndexPaths}}) 
        {
          $xfer += $output->writeString($iter329);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_loadIndex_result;
use base qw(Class::Accessor);
Blur::Blur_loadIndex_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_loadIndex_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_loadIndex_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_args;
use base qw(Class::Accessor);
Blur::Blur_mutate_args->mk_accessors( qw( mutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation}) {
      $self->{mutation} = $vals->{mutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutation} = new Blur::RowMutation();
        $xfer += $self->{mutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_args');
  if (defined $self->{mutation}) {
    $xfer += $output->writeFieldBegin('mutation', TType::STRUCT, 1);
    $xfer += $self->{mutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_result;
use base qw(Class::Accessor);
Blur::Blur_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enqueueMutate_args;
use base qw(Class::Accessor);
Blur::Blur_enqueueMutate_args->mk_accessors( qw( mutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation}) {
      $self->{mutation} = $vals->{mutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enqueueMutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutation} = new Blur::RowMutation();
        $xfer += $self->{mutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enqueueMutate_args');
  if (defined $self->{mutation}) {
    $xfer += $output->writeFieldBegin('mutation', TType::STRUCT, 1);
    $xfer += $self->{mutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enqueueMutate_result;
use base qw(Class::Accessor);
Blur::Blur_enqueueMutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enqueueMutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enqueueMutate_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_args;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_args->mk_accessors( qw( mutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size330 = 0;
          $self->{mutations} = [];
          my $_etype333 = 0;
          $xfer += $input->readListBegin(\$_etype333, \$_size330);
          for (my $_i334 = 0; $_i334 < $_size330; ++$_i334)
          {
            my $elem335 = undef;
            $elem335 = new Blur::RowMutation();
            $xfer += $elem335->read($input);
            push(@{$self->{mutations}},$elem335);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_args');
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter336 (@{$self->{mutations}}) 
        {
          $xfer += ${iter336}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_result;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enqueueMutateBatch_args;
use base qw(Class::Accessor);
Blur::Blur_enqueueMutateBatch_args->mk_accessors( qw( mutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enqueueMutateBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size337 = 0;
          $self->{mutations} = [];
          my $_etype340 = 0;
          $xfer += $input->readListBegin(\$_etype340, \$_size337);
          for (my $_i341 = 0; $_i341 < $_size337; ++$_i341)
          {
            my $elem342 = undef;
            $elem342 = new Blur::RowMutation();
            $xfer += $elem342->read($input);
            push(@{$self->{mutations}},$elem342);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enqueueMutateBatch_args');
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter343 (@{$self->{mutations}}) 
        {
          $xfer += ${iter343}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enqueueMutateBatch_result;
use base qw(Class::Accessor);
Blur::Blur_enqueueMutateBatch_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enqueueMutateBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enqueueMutateBatch_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateStart_args;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateStart_args->mk_accessors( qw( bulkId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bulkId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bulkId}) {
      $self->{bulkId} = $vals->{bulkId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateStart_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{bulkId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateStart_args');
  if (defined $self->{bulkId}) {
    $xfer += $output->writeFieldBegin('bulkId', TType::STRING, 1);
    $xfer += $output->writeString($self->{bulkId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateStart_result;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateStart_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateStart_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateStart_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateAdd_args;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateAdd_args->mk_accessors( qw( bulkId rowMutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bulkId} = undef;
  $self->{rowMutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bulkId}) {
      $self->{bulkId} = $vals->{bulkId};
    }
    if (defined $vals->{rowMutation}) {
      $self->{rowMutation} = $vals->{rowMutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateAdd_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{bulkId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowMutation} = new Blur::RowMutation();
        $xfer += $self->{rowMutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateAdd_args');
  if (defined $self->{bulkId}) {
    $xfer += $output->writeFieldBegin('bulkId', TType::STRING, 1);
    $xfer += $output->writeString($self->{bulkId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutation}) {
    $xfer += $output->writeFieldBegin('rowMutation', TType::STRUCT, 2);
    $xfer += $self->{rowMutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateAdd_result;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateAdd_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateAdd_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateAdd_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateAddMultiple_args;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateAddMultiple_args->mk_accessors( qw( bulkId rowMutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bulkId} = undef;
  $self->{rowMutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bulkId}) {
      $self->{bulkId} = $vals->{bulkId};
    }
    if (defined $vals->{rowMutations}) {
      $self->{rowMutations} = $vals->{rowMutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateAddMultiple_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{bulkId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size344 = 0;
          $self->{rowMutations} = [];
          my $_etype347 = 0;
          $xfer += $input->readListBegin(\$_etype347, \$_size344);
          for (my $_i348 = 0; $_i348 < $_size344; ++$_i348)
          {
            my $elem349 = undef;
            $elem349 = new Blur::RowMutation();
            $xfer += $elem349->read($input);
            push(@{$self->{rowMutations}},$elem349);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateAddMultiple_args');
  if (defined $self->{bulkId}) {
    $xfer += $output->writeFieldBegin('bulkId', TType::STRING, 1);
    $xfer += $output->writeString($self->{bulkId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutations}) {
    $xfer += $output->writeFieldBegin('rowMutations', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rowMutations}}));
      {
        foreach my $iter350 (@{$self->{rowMutations}}) 
        {
          $xfer += ${iter350}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateAddMultiple_result;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateAddMultiple_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateAddMultiple_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateAddMultiple_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateFinish_args;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateFinish_args->mk_accessors( qw( bulkId apply blockUntilComplete ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bulkId} = undef;
  $self->{apply} = undef;
  $self->{blockUntilComplete} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bulkId}) {
      $self->{bulkId} = $vals->{bulkId};
    }
    if (defined $vals->{apply}) {
      $self->{apply} = $vals->{apply};
    }
    if (defined $vals->{blockUntilComplete}) {
      $self->{blockUntilComplete} = $vals->{blockUntilComplete};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateFinish_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{bulkId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{apply});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{blockUntilComplete});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateFinish_args');
  if (defined $self->{bulkId}) {
    $xfer += $output->writeFieldBegin('bulkId', TType::STRING, 1);
    $xfer += $output->writeString($self->{bulkId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{apply}) {
    $xfer += $output->writeFieldBegin('apply', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{apply});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockUntilComplete}) {
    $xfer += $output->writeFieldBegin('blockUntilComplete', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{blockUntilComplete});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_bulkMutateFinish_result;
use base qw(Class::Accessor);
Blur::Blur_bulkMutateFinish_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_bulkMutateFinish_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_bulkMutateFinish_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_args;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_result;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size351 = 0;
          $self->{success} = [];
          my $_etype354 = 0;
          $xfer += $input->readListBegin(\$_etype354, \$_size351);
          for (my $_i355 = 0; $_i355 < $_size351; ++$_i355)
          {
            my $elem356 = undef;
            $xfer += $input->readString(\$elem356);
            push(@{$self->{success}},$elem356);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter357 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter357);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurQueryStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_args;
use base qw(Class::Accessor);
Blur::Blur_terms_args->mk_accessors( qw( table columnFamily columnName startWith size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{startWith} = undef;
  $self->{size} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{startWith}) {
      $self->{startWith} = $vals->{startWith};
    }
    if (defined $vals->{size}) {
      $self->{size} = $vals->{size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startWith});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startWith}) {
    $xfer += $output->writeFieldBegin('startWith', TType::STRING, 4);
    $xfer += $output->writeString($self->{startWith});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{size}) {
    $xfer += $output->writeFieldBegin('size', TType::I16, 5);
    $xfer += $output->writeI16($self->{size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_result;
use base qw(Class::Accessor);
Blur::Blur_terms_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size358 = 0;
          $self->{success} = [];
          my $_etype361 = 0;
          $xfer += $input->readListBegin(\$_etype361, \$_size358);
          for (my $_i362 = 0; $_i362 < $_size358; ++$_i362)
          {
            my $elem363 = undef;
            $xfer += $input->readString(\$elem363);
            push(@{$self->{success}},$elem363);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter364 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter364);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_args;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_args->mk_accessors( qw( table columnFamily columnName value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_result;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_result;
use base qw(Class::Accessor);
Blur::Blur_shardClusterList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size365 = 0;
          $self->{success} = [];
          my $_etype368 = 0;
          $xfer += $input->readListBegin(\$_etype368, \$_size365);
          for (my $_i369 = 0; $_i369 < $_size365; ++$_i369)
          {
            my $elem370 = undef;
            $xfer += $input->readString(\$elem370);
            push(@{$self->{success}},$elem370);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter371 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter371);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size372 = 0;
          $self->{success} = [];
          my $_etype375 = 0;
          $xfer += $input->readListBegin(\$_etype375, \$_size372);
          for (my $_i376 = 0; $_i376 < $_size372; ++$_i376)
          {
            my $elem377 = undef;
            $xfer += $input->readString(\$elem377);
            push(@{$self->{success}},$elem377);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter378 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter378);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_result;
use base qw(Class::Accessor);
Blur::Blur_controllerServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size379 = 0;
          $self->{success} = [];
          my $_etype382 = 0;
          $xfer += $input->readListBegin(\$_etype382, \$_size379);
          for (my $_i383 = 0; $_i383 < $_size379; ++$_i383)
          {
            my $elem384 = undef;
            $xfer += $input->readString(\$elem384);
            push(@{$self->{success}},$elem384);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter385 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter385);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size386 = 0;
          $self->{success} = {};
          my $_ktype387 = 0;
          my $_vtype388 = 0;
          $xfer += $input->readMapBegin(\$_ktype387, \$_vtype388, \$_size386);
          for (my $_i390 = 0; $_i390 < $_size386; ++$_i390)
          {
            my $key391 = '';
            my $val392 = '';
            $xfer += $input->readString(\$key391);
            $xfer += $input->readString(\$val392);
            $self->{success}->{$key391} = $val392;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter393,$viter394) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter393);
          $xfer += $output->writeString($viter394);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size395 = 0;
          $self->{success} = {};
          my $_ktype396 = 0;
          my $_vtype397 = 0;
          $xfer += $input->readMapBegin(\$_ktype396, \$_vtype397, \$_size395);
          for (my $_i399 = 0; $_i399 < $_size395; ++$_i399)
          {
            my $key400 = '';
            my $val401 = [];
            $xfer += $input->readString(\$key400);
            {
              my $_size402 = 0;
              $val401 = {};
              my $_ktype403 = 0;
              my $_vtype404 = 0;
              $xfer += $input->readMapBegin(\$_ktype403, \$_vtype404, \$_size402);
              for (my $_i406 = 0; $_i406 < $_size402; ++$_i406)
              {
                my $key407 = '';
                my $val408 = 0;
                $xfer += $input->readString(\$key407);
                $xfer += $input->readI32(\$val408);
                $val401->{$key407} = $val408;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key400} = $val401;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter409,$viter410) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter409);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{${viter410}}));
            {
              while( my ($kiter411,$viter412) = each %{${viter410}}) 
              {
                $xfer += $output->writeString($kiter411);
                $xfer += $output->writeI32($viter412);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_args;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_result;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_result;
use base qw(Class::Accessor);
Blur::Blur_configuration_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size413 = 0;
          $self->{success} = {};
          my $_ktype414 = 0;
          my $_vtype415 = 0;
          $xfer += $input->readMapBegin(\$_ktype414, \$_vtype415, \$_size413);
          for (my $_i417 = 0; $_i417 < $_size413; ++$_i417)
          {
            my $key418 = '';
            my $val419 = '';
            $xfer += $input->readString(\$key418);
            $xfer += $input->readString(\$val419);
            $self->{success}->{$key418} = $val419;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter420,$viter421) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter420);
          $xfer += $output->writeString($viter421);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configurationPerServer_args;
use base qw(Class::Accessor);
Blur::Blur_configurationPerServer_args->mk_accessors( qw( thriftServerPlusPort configName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thriftServerPlusPort} = undef;
  $self->{configName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thriftServerPlusPort}) {
      $self->{thriftServerPlusPort} = $vals->{thriftServerPlusPort};
    }
    if (defined $vals->{configName}) {
      $self->{configName} = $vals->{configName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configurationPerServer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{thriftServerPlusPort});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{configName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configurationPerServer_args');
  if (defined $self->{thriftServerPlusPort}) {
    $xfer += $output->writeFieldBegin('thriftServerPlusPort', TType::STRING, 1);
    $xfer += $output->writeString($self->{thriftServerPlusPort});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{configName}) {
    $xfer += $output->writeFieldBegin('configName', TType::STRING, 2);
    $xfer += $output->writeString($self->{configName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configurationPerServer_result;
use base qw(Class::Accessor);
Blur::Blur_configurationPerServer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configurationPerServer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configurationPerServer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_args;
use base qw(Class::Accessor);
Blur::Blur_metrics_args->mk_accessors( qw( metrics ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{metrics} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{metrics}) {
      $self->{metrics} = $vals->{metrics};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size422 = 0;
          $self->{metrics} = {};
          my $_etype425 = 0;
          $xfer += $input->readSetBegin(\$_etype425, \$_size422);
          for (my $_i426 = 0; $_i426 < $_size422; ++$_i426)
          {
            my $elem427 = undef;
            $xfer += $input->readString(\$elem427);
            $self->{metrics}->{$elem427} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_args');
  if (defined $self->{metrics}) {
    $xfer += $output->writeFieldBegin('metrics', TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{metrics}}));
      {
        foreach my $iter428 (@{$self->{metrics}})
        {
          $xfer += $output->writeString($iter428);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_result;
use base qw(Class::Accessor);
Blur::Blur_metrics_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size429 = 0;
          $self->{success} = {};
          my $_ktype430 = 0;
          my $_vtype431 = 0;
          $xfer += $input->readMapBegin(\$_ktype430, \$_vtype431, \$_size429);
          for (my $_i433 = 0; $_i433 < $_size429; ++$_i433)
          {
            my $key434 = '';
            my $val435 = new Blur::Metric();
            $xfer += $input->readString(\$key434);
            $val435 = new Blur::Metric();
            $xfer += $val435->read($input);
            $self->{success}->{$key434} = $val435;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter436,$viter437) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter436);
          $xfer += ${viter437}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_startTrace_args;
use base qw(Class::Accessor);
Blur::Blur_startTrace_args->mk_accessors( qw( traceId requestId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{traceId} = undef;
  $self->{requestId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{traceId}) {
      $self->{traceId} = $vals->{traceId};
    }
    if (defined $vals->{requestId}) {
      $self->{requestId} = $vals->{requestId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_startTrace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{traceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{requestId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_startTrace_args');
  if (defined $self->{traceId}) {
    $xfer += $output->writeFieldBegin('traceId', TType::STRING, 1);
    $xfer += $output->writeString($self->{traceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{requestId}) {
    $xfer += $output->writeFieldBegin('requestId', TType::STRING, 2);
    $xfer += $output->writeString($self->{requestId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_startTrace_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_startTrace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_startTrace_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceList_result;
use base qw(Class::Accessor);
Blur::Blur_traceList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size438 = 0;
          $self->{success} = [];
          my $_etype441 = 0;
          $xfer += $input->readListBegin(\$_etype441, \$_size438);
          for (my $_i442 = 0; $_i442 < $_size438; ++$_i442)
          {
            my $elem443 = undef;
            $xfer += $input->readString(\$elem443);
            push(@{$self->{success}},$elem443);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter444 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter444);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRequestList_args;
use base qw(Class::Accessor);
Blur::Blur_traceRequestList_args->mk_accessors( qw( traceId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{traceId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{traceId}) {
      $self->{traceId} = $vals->{traceId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRequestList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{traceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRequestList_args');
  if (defined $self->{traceId}) {
    $xfer += $output->writeFieldBegin('traceId', TType::STRING, 1);
    $xfer += $output->writeString($self->{traceId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRequestList_result;
use base qw(Class::Accessor);
Blur::Blur_traceRequestList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRequestList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size445 = 0;
          $self->{success} = [];
          my $_etype448 = 0;
          $xfer += $input->readListBegin(\$_etype448, \$_size445);
          for (my $_i449 = 0; $_i449 < $_size445; ++$_i449)
          {
            my $elem450 = undef;
            $xfer += $input->readString(\$elem450);
            push(@{$self->{success}},$elem450);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRequestList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter451 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter451);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRequestFetch_args;
use base qw(Class::Accessor);
Blur::Blur_traceRequestFetch_args->mk_accessors( qw( traceId requestId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{traceId} = undef;
  $self->{requestId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{traceId}) {
      $self->{traceId} = $vals->{traceId};
    }
    if (defined $vals->{requestId}) {
      $self->{requestId} = $vals->{requestId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRequestFetch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{traceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{requestId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRequestFetch_args');
  if (defined $self->{traceId}) {
    $xfer += $output->writeFieldBegin('traceId', TType::STRING, 1);
    $xfer += $output->writeString($self->{traceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{requestId}) {
    $xfer += $output->writeFieldBegin('requestId', TType::STRING, 2);
    $xfer += $output->writeString($self->{requestId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRequestFetch_result;
use base qw(Class::Accessor);
Blur::Blur_traceRequestFetch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRequestFetch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRequestFetch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRemove_args;
use base qw(Class::Accessor);
Blur::Blur_traceRemove_args->mk_accessors( qw( traceId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{traceId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{traceId}) {
      $self->{traceId} = $vals->{traceId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRemove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{traceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRemove_args');
  if (defined $self->{traceId}) {
    $xfer += $output->writeFieldBegin('traceId', TType::STRING, 1);
    $xfer += $output->writeString($self->{traceId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_traceRemove_result;
use base qw(Class::Accessor);
Blur::Blur_traceRemove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_traceRemove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_traceRemove_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_ping_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_ping_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_ping_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_ping_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_ping_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_ping_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_logging_args;
use base qw(Class::Accessor);
Blur::Blur_logging_args->mk_accessors( qw( classNameOrLoggerName level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{classNameOrLoggerName} = undef;
  $self->{level} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{classNameOrLoggerName}) {
      $self->{classNameOrLoggerName} = $vals->{classNameOrLoggerName};
    }
    if (defined $vals->{level}) {
      $self->{level} = $vals->{level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_logging_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{classNameOrLoggerName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_logging_args');
  if (defined $self->{classNameOrLoggerName}) {
    $xfer += $output->writeFieldBegin('classNameOrLoggerName', TType::STRING, 1);
    $xfer += $output->writeString($self->{classNameOrLoggerName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{level}) {
    $xfer += $output->writeFieldBegin('level', TType::I32, 2);
    $xfer += $output->writeI32($self->{level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_logging_result;
use base qw(Class::Accessor);
Blur::Blur_logging_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_logging_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_logging_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_resetLogging_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_resetLogging_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_resetLogging_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_resetLogging_result;
use base qw(Class::Accessor);
Blur::Blur_resetLogging_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_resetLogging_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_resetLogging_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurIf;

use strict;


sub listInstalledCommands{
  my $self = shift;

  die 'implement interface';
}

sub execute{
  my $self = shift;
  my $commandName = shift;
  my $arguments = shift;

  die 'implement interface';
}

sub reconnect{
  my $self = shift;
  my $instanceExecutionId = shift;

  die 'implement interface';
}

sub commandStatusList{
  my $self = shift;
  my $startingAt = shift;
  my $fetch = shift;
  my $state = shift;

  die 'implement interface';
}

sub commandStatus{
  my $self = shift;
  my $commandExecutionId = shift;

  die 'implement interface';
}

sub commandCancel{
  my $self = shift;
  my $commandExecutionId = shift;

  die 'implement interface';
}

sub refresh{
  my $self = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  die 'implement interface';
}

sub enableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  die 'implement interface';
}

sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  die 'implement interface';
}

sub tableList{
  my $self = shift;

  die 'implement interface';
}

sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub describe{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub schema{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

  die 'implement interface';
}

sub tableStats{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  die 'implement interface';
}

sub createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  die 'implement interface';
}

sub removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  die 'implement interface';
}

sub listSnapshots{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub setUser{
  my $self = shift;
  my $user = shift;

  die 'implement interface';
}

sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  die 'implement interface';
}

sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  die 'implement interface';
}

sub fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

  die 'implement interface';
}

sub loadData{
  my $self = shift;
  my $table = shift;
  my $location = shift;

  die 'implement interface';
}

sub validateIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

  die 'implement interface';
}

sub loadIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

  die 'implement interface';
}

sub mutate{
  my $self = shift;
  my $mutation = shift;

  die 'implement interface';
}

sub enqueueMutate{
  my $self = shift;
  my $mutation = shift;

  die 'implement interface';
}

sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

  die 'implement interface';
}

sub enqueueMutateBatch{
  my $self = shift;
  my $mutations = shift;

  die 'implement interface';
}

sub bulkMutateStart{
  my $self = shift;
  my $bulkId = shift;

  die 'implement interface';
}

sub bulkMutateAdd{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutation = shift;

  die 'implement interface';
}

sub bulkMutateAddMultiple{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutations = shift;

  die 'implement interface';
}

sub bulkMutateFinish{
  my $self = shift;
  my $bulkId = shift;
  my $apply = shift;
  my $blockUntilComplete = shift;

  die 'implement interface';
}

sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  die 'implement interface';
}

sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  die 'implement interface';
}

sub shardClusterList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerList{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub controllerServerList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerLayout{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub configuration{
  my $self = shift;

  die 'implement interface';
}

sub configurationPerServer{
  my $self = shift;
  my $thriftServerPlusPort = shift;
  my $configName = shift;

  die 'implement interface';
}

sub metrics{
  my $self = shift;
  my $metrics = shift;

  die 'implement interface';
}

sub startTrace{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

  die 'implement interface';
}

sub traceList{
  my $self = shift;

  die 'implement interface';
}

sub traceRequestList{
  my $self = shift;
  my $traceId = shift;

  die 'implement interface';
}

sub traceRequestFetch{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

  die 'implement interface';
}

sub traceRemove{
  my $self = shift;
  my $traceId = shift;

  die 'implement interface';
}

sub ping{
  my $self = shift;

  die 'implement interface';
}

sub logging{
  my $self = shift;
  my $classNameOrLoggerName = shift;
  my $level = shift;

  die 'implement interface';
}

sub resetLogging{
  my $self = shift;

  die 'implement interface';
}

package Blur::BlurRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub listInstalledCommands{
  my ($self, $request) = @_;

  return $self->{impl}->listInstalledCommands();
}

sub execute{
  my ($self, $request) = @_;

  my $commandName = ($request->{'commandName'}) ? $request->{'commandName'} : undef;
  my $arguments = ($request->{'arguments'}) ? $request->{'arguments'} : undef;
  return $self->{impl}->execute($commandName, $arguments);
}

sub reconnect{
  my ($self, $request) = @_;

  my $instanceExecutionId = ($request->{'instanceExecutionId'}) ? $request->{'instanceExecutionId'} : undef;
  return $self->{impl}->reconnect($instanceExecutionId);
}

sub commandStatusList{
  my ($self, $request) = @_;

  my $startingAt = ($request->{'startingAt'}) ? $request->{'startingAt'} : undef;
  my $fetch = ($request->{'fetch'}) ? $request->{'fetch'} : undef;
  my $state = ($request->{'state'}) ? $request->{'state'} : undef;
  return $self->{impl}->commandStatusList($startingAt, $fetch, $state);
}

sub commandStatus{
  my ($self, $request) = @_;

  my $commandExecutionId = ($request->{'commandExecutionId'}) ? $request->{'commandExecutionId'} : undef;
  return $self->{impl}->commandStatus($commandExecutionId);
}

sub commandCancel{
  my ($self, $request) = @_;

  my $commandExecutionId = ($request->{'commandExecutionId'}) ? $request->{'commandExecutionId'} : undef;
  return $self->{impl}->commandCancel($commandExecutionId);
}

sub refresh{
  my ($self, $request) = @_;

  return $self->{impl}->refresh();
}

sub createTable{
  my ($self, $request) = @_;

  my $tableDescriptor = ($request->{'tableDescriptor'}) ? $request->{'tableDescriptor'} : undef;
  return $self->{impl}->createTable($tableDescriptor);
}

sub enableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->enableTable($table);
}

sub disableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->disableTable($table);
}

sub removeTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deleteIndexFiles = ($request->{'deleteIndexFiles'}) ? $request->{'deleteIndexFiles'} : undef;
  return $self->{impl}->removeTable($table, $deleteIndexFiles);
}

sub addColumnDefinition{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnDefinition = ($request->{'columnDefinition'}) ? $request->{'columnDefinition'} : undef;
  return $self->{impl}->addColumnDefinition($table, $columnDefinition);
}

sub tableList{
  my ($self, $request) = @_;

  return $self->{impl}->tableList();
}

sub tableListByCluster{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->tableListByCluster($cluster);
}

sub describe{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->describe($table);
}

sub schema{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->schema($table);
}

sub parseQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  return $self->{impl}->parseQuery($table, $query);
}

sub tableStats{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->tableStats($table);
}

sub optimize{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $numberOfSegmentsPerShard = ($request->{'numberOfSegmentsPerShard'}) ? $request->{'numberOfSegmentsPerShard'} : undef;
  return $self->{impl}->optimize($table, $numberOfSegmentsPerShard);
}

sub createSnapshot{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->createSnapshot($table, $name);
}

sub removeSnapshot{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->removeSnapshot($table, $name);
}

sub listSnapshots{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->listSnapshots($table);
}

sub setUser{
  my ($self, $request) = @_;

  my $user = ($request->{'user'}) ? $request->{'user'} : undef;
  return $self->{impl}->setUser($user);
}

sub query{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $blurQuery = ($request->{'blurQuery'}) ? $request->{'blurQuery'} : undef;
  return $self->{impl}->query($table, $blurQuery);
}

sub fetchRow{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selector = ($request->{'selector'}) ? $request->{'selector'} : undef;
  return $self->{impl}->fetchRow($table, $selector);
}

sub fetchRowBatch{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selectors = ($request->{'selectors'}) ? $request->{'selectors'} : undef;
  return $self->{impl}->fetchRowBatch($table, $selectors);
}

sub loadData{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $location = ($request->{'location'}) ? $request->{'location'} : undef;
  return $self->{impl}->loadData($table, $location);
}

sub validateIndex{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $externalIndexPaths = ($request->{'externalIndexPaths'}) ? $request->{'externalIndexPaths'} : undef;
  return $self->{impl}->validateIndex($table, $externalIndexPaths);
}

sub loadIndex{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $externalIndexPaths = ($request->{'externalIndexPaths'}) ? $request->{'externalIndexPaths'} : undef;
  return $self->{impl}->loadIndex($table, $externalIndexPaths);
}

sub mutate{
  my ($self, $request) = @_;

  my $mutation = ($request->{'mutation'}) ? $request->{'mutation'} : undef;
  return $self->{impl}->mutate($mutation);
}

sub enqueueMutate{
  my ($self, $request) = @_;

  my $mutation = ($request->{'mutation'}) ? $request->{'mutation'} : undef;
  return $self->{impl}->enqueueMutate($mutation);
}

sub mutateBatch{
  my ($self, $request) = @_;

  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  return $self->{impl}->mutateBatch($mutations);
}

sub enqueueMutateBatch{
  my ($self, $request) = @_;

  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  return $self->{impl}->enqueueMutateBatch($mutations);
}

sub bulkMutateStart{
  my ($self, $request) = @_;

  my $bulkId = ($request->{'bulkId'}) ? $request->{'bulkId'} : undef;
  return $self->{impl}->bulkMutateStart($bulkId);
}

sub bulkMutateAdd{
  my ($self, $request) = @_;

  my $bulkId = ($request->{'bulkId'}) ? $request->{'bulkId'} : undef;
  my $rowMutation = ($request->{'rowMutation'}) ? $request->{'rowMutation'} : undef;
  return $self->{impl}->bulkMutateAdd($bulkId, $rowMutation);
}

sub bulkMutateAddMultiple{
  my ($self, $request) = @_;

  my $bulkId = ($request->{'bulkId'}) ? $request->{'bulkId'} : undef;
  my $rowMutations = ($request->{'rowMutations'}) ? $request->{'rowMutations'} : undef;
  return $self->{impl}->bulkMutateAddMultiple($bulkId, $rowMutations);
}

sub bulkMutateFinish{
  my ($self, $request) = @_;

  my $bulkId = ($request->{'bulkId'}) ? $request->{'bulkId'} : undef;
  my $apply = ($request->{'apply'}) ? $request->{'apply'} : undef;
  my $blockUntilComplete = ($request->{'blockUntilComplete'}) ? $request->{'blockUntilComplete'} : undef;
  return $self->{impl}->bulkMutateFinish($bulkId, $apply, $blockUntilComplete);
}

sub cancelQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->cancelQuery($table, $uuid);
}

sub queryStatusIdList{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->queryStatusIdList($table);
}

sub queryStatusById{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->queryStatusById($table, $uuid);
}

sub terms{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $startWith = ($request->{'startWith'}) ? $request->{'startWith'} : undef;
  my $size = ($request->{'size'}) ? $request->{'size'} : undef;
  return $self->{impl}->terms($table, $columnFamily, $columnName, $startWith, $size);
}

sub recordFrequency{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->recordFrequency($table, $columnFamily, $columnName, $value);
}

sub shardClusterList{
  my ($self, $request) = @_;

  return $self->{impl}->shardClusterList();
}

sub shardServerList{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->shardServerList($cluster);
}

sub controllerServerList{
  my ($self, $request) = @_;

  return $self->{impl}->controllerServerList();
}

sub shardServerLayout{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayout($table);
}

sub shardServerLayoutState{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayoutState($table);
}

sub isInSafeMode{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->isInSafeMode($cluster);
}

sub configuration{
  my ($self, $request) = @_;

  return $self->{impl}->configuration();
}

sub configurationPerServer{
  my ($self, $request) = @_;

  my $thriftServerPlusPort = ($request->{'thriftServerPlusPort'}) ? $request->{'thriftServerPlusPort'} : undef;
  my $configName = ($request->{'configName'}) ? $request->{'configName'} : undef;
  return $self->{impl}->configurationPerServer($thriftServerPlusPort, $configName);
}

sub metrics{
  my ($self, $request) = @_;

  my $metrics = ($request->{'metrics'}) ? $request->{'metrics'} : undef;
  return $self->{impl}->metrics($metrics);
}

sub startTrace{
  my ($self, $request) = @_;

  my $traceId = ($request->{'traceId'}) ? $request->{'traceId'} : undef;
  my $requestId = ($request->{'requestId'}) ? $request->{'requestId'} : undef;
  return $self->{impl}->startTrace($traceId, $requestId);
}

sub traceList{
  my ($self, $request) = @_;

  return $self->{impl}->traceList();
}

sub traceRequestList{
  my ($self, $request) = @_;

  my $traceId = ($request->{'traceId'}) ? $request->{'traceId'} : undef;
  return $self->{impl}->traceRequestList($traceId);
}

sub traceRequestFetch{
  my ($self, $request) = @_;

  my $traceId = ($request->{'traceId'}) ? $request->{'traceId'} : undef;
  my $requestId = ($request->{'requestId'}) ? $request->{'requestId'} : undef;
  return $self->{impl}->traceRequestFetch($traceId, $requestId);
}

sub traceRemove{
  my ($self, $request) = @_;

  my $traceId = ($request->{'traceId'}) ? $request->{'traceId'} : undef;
  return $self->{impl}->traceRemove($traceId);
}

sub ping{
  my ($self, $request) = @_;

  return $self->{impl}->ping();
}

sub logging{
  my ($self, $request) = @_;

  my $classNameOrLoggerName = ($request->{'classNameOrLoggerName'}) ? $request->{'classNameOrLoggerName'} : undef;
  my $level = ($request->{'level'}) ? $request->{'level'} : undef;
  return $self->{impl}->logging($classNameOrLoggerName, $level);
}

sub resetLogging{
  my ($self, $request) = @_;

  return $self->{impl}->resetLogging();
}

package Blur::BlurClient;


use base qw(Blur::BlurIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub listInstalledCommands{
  my $self = shift;

    $self->send_listInstalledCommands();
  return $self->recv_listInstalledCommands();
}

sub send_listInstalledCommands{
  my $self = shift;

  $self->{output}->writeMessageBegin('listInstalledCommands', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_listInstalledCommands_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listInstalledCommands{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_listInstalledCommands_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "listInstalledCommands failed: unknown result";
}
sub execute{
  my $self = shift;
  my $commandName = shift;
  my $arguments = shift;

    $self->send_execute($commandName, $arguments);
  return $self->recv_execute();
}

sub send_execute{
  my $self = shift;
  my $commandName = shift;
  my $arguments = shift;

  $self->{output}->writeMessageBegin('execute', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_execute_args();
  $args->{commandName} = $commandName;
  $args->{arguments} = $arguments;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_execute_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{bex}) {
    die $result->{bex};
  }
  if (defined $result->{tex}) {
    die $result->{tex};
  }
  die "execute failed: unknown result";
}
sub reconnect{
  my $self = shift;
  my $instanceExecutionId = shift;

    $self->send_reconnect($instanceExecutionId);
  return $self->recv_reconnect();
}

sub send_reconnect{
  my $self = shift;
  my $instanceExecutionId = shift;

  $self->{output}->writeMessageBegin('reconnect', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_reconnect_args();
  $args->{instanceExecutionId} = $instanceExecutionId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_reconnect{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_reconnect_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{bex}) {
    die $result->{bex};
  }
  if (defined $result->{tex}) {
    die $result->{tex};
  }
  die "reconnect failed: unknown result";
}
sub commandStatusList{
  my $self = shift;
  my $startingAt = shift;
  my $fetch = shift;
  my $state = shift;

    $self->send_commandStatusList($startingAt, $fetch, $state);
  return $self->recv_commandStatusList();
}

sub send_commandStatusList{
  my $self = shift;
  my $startingAt = shift;
  my $fetch = shift;
  my $state = shift;

  $self->{output}->writeMessageBegin('commandStatusList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_commandStatusList_args();
  $args->{startingAt} = $startingAt;
  $args->{fetch} = $fetch;
  $args->{state} = $state;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_commandStatusList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_commandStatusList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "commandStatusList failed: unknown result";
}
sub commandStatus{
  my $self = shift;
  my $commandExecutionId = shift;

    $self->send_commandStatus($commandExecutionId);
  return $self->recv_commandStatus();
}

sub send_commandStatus{
  my $self = shift;
  my $commandExecutionId = shift;

  $self->{output}->writeMessageBegin('commandStatus', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_commandStatus_args();
  $args->{commandExecutionId} = $commandExecutionId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_commandStatus{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_commandStatus_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "commandStatus failed: unknown result";
}
sub commandCancel{
  my $self = shift;
  my $commandExecutionId = shift;

    $self->send_commandCancel($commandExecutionId);
  $self->recv_commandCancel();
}

sub send_commandCancel{
  my $self = shift;
  my $commandExecutionId = shift;

  $self->{output}->writeMessageBegin('commandCancel', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_commandCancel_args();
  $args->{commandExecutionId} = $commandExecutionId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_commandCancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_commandCancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub refresh{
  my $self = shift;

    $self->send_refresh();
}

sub send_refresh{
  my $self = shift;

  $self->{output}->writeMessageBegin('refresh', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_refresh_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

    $self->send_createTable($tableDescriptor);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createTable_args();
  $args->{tableDescriptor} = $tableDescriptor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enableTable{
  my $self = shift;
  my $table = shift;

    $self->send_enableTable($table);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $table = shift;

    $self->send_disableTable($table);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_disableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

    $self->send_removeTable($table, $deleteIndexFiles);
  $self->recv_removeTable();
}

sub send_removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  $self->{output}->writeMessageBegin('removeTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeTable_args();
  $args->{table} = $table;
  $args->{deleteIndexFiles} = $deleteIndexFiles;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

    $self->send_addColumnDefinition($table, $columnDefinition);
  return $self->recv_addColumnDefinition();
}

sub send_addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  $self->{output}->writeMessageBegin('addColumnDefinition', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_addColumnDefinition_args();
  $args->{table} = $table;
  $args->{columnDefinition} = $columnDefinition;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_addColumnDefinition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_addColumnDefinition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "addColumnDefinition failed: unknown result";
}
sub tableList{
  my $self = shift;

    $self->send_tableList();
  return $self->recv_tableList();
}

sub send_tableList{
  my $self = shift;

  $self->{output}->writeMessageBegin('tableList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableList failed: unknown result";
}
sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

    $self->send_tableListByCluster($cluster);
  return $self->recv_tableListByCluster();
}

sub send_tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('tableListByCluster', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableListByCluster_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableListByCluster{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableListByCluster_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableListByCluster failed: unknown result";
}
sub describe{
  my $self = shift;
  my $table = shift;

    $self->send_describe($table);
  return $self->recv_describe();
}

sub send_describe{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('describe', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_describe_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_describe_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "describe failed: unknown result";
}
sub schema{
  my $self = shift;
  my $table = shift;

    $self->send_schema($table);
  return $self->recv_schema();
}

sub send_schema{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('schema', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_schema_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "schema failed: unknown result";
}
sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

    $self->send_parseQuery($table, $query);
  return $self->recv_parseQuery();
}

sub send_parseQuery{
  my $self = shift;
  my $table = shift;
  my $query = shift;

  $self->{output}->writeMessageBegin('parseQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_parseQuery_args();
  $args->{table} = $table;
  $args->{query} = $query;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parseQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_parseQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "parseQuery failed: unknown result";
}
sub tableStats{
  my $self = shift;
  my $table = shift;

    $self->send_tableStats($table);
  return $self->recv_tableStats();
}

sub send_tableStats{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('tableStats', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableStats_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableStats{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableStats_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableStats failed: unknown result";
}
sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

    $self->send_optimize($table, $numberOfSegmentsPerShard);
  $self->recv_optimize();
}

sub send_optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  $self->{output}->writeMessageBegin('optimize', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_optimize_args();
  $args->{table} = $table;
  $args->{numberOfSegmentsPerShard} = $numberOfSegmentsPerShard;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_optimize{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_optimize_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

    $self->send_createSnapshot($table, $name);
  $self->recv_createSnapshot();
}

sub send_createSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('createSnapshot', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createSnapshot_args();
  $args->{table} = $table;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createSnapshot{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createSnapshot_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

    $self->send_removeSnapshot($table, $name);
  $self->recv_removeSnapshot();
}

sub send_removeSnapshot{
  my $self = shift;
  my $table = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('removeSnapshot', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeSnapshot_args();
  $args->{table} = $table;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeSnapshot{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeSnapshot_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub listSnapshots{
  my $self = shift;
  my $table = shift;

    $self->send_listSnapshots($table);
  return $self->recv_listSnapshots();
}

sub send_listSnapshots{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('listSnapshots', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_listSnapshots_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listSnapshots{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_listSnapshots_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "listSnapshots failed: unknown result";
}
sub setUser{
  my $self = shift;
  my $user = shift;

    $self->send_setUser($user);
}

sub send_setUser{
  my $self = shift;
  my $user = shift;

  $self->{output}->writeMessageBegin('setUser', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_setUser_args();
  $args->{user} = $user;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

    $self->send_query($table, $blurQuery);
  return $self->recv_query();
}

sub send_query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  $self->{output}->writeMessageBegin('query', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_query_args();
  $args->{table} = $table;
  $args->{blurQuery} = $blurQuery;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "query failed: unknown result";
}
sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

    $self->send_fetchRow($table, $selector);
  return $self->recv_fetchRow();
}

sub send_fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  $self->{output}->writeMessageBegin('fetchRow', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRow_args();
  $args->{table} = $table;
  $args->{selector} = $selector;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRow failed: unknown result";
}
sub fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

    $self->send_fetchRowBatch($table, $selectors);
  return $self->recv_fetchRowBatch();
}

sub send_fetchRowBatch{
  my $self = shift;
  my $table = shift;
  my $selectors = shift;

  $self->{output}->writeMessageBegin('fetchRowBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRowBatch_args();
  $args->{table} = $table;
  $args->{selectors} = $selectors;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRowBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRowBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRowBatch failed: unknown result";
}
sub loadData{
  my $self = shift;
  my $table = shift;
  my $location = shift;

    $self->send_loadData($table, $location);
  $self->recv_loadData();
}

sub send_loadData{
  my $self = shift;
  my $table = shift;
  my $location = shift;

  $self->{output}->writeMessageBegin('loadData', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_loadData_args();
  $args->{table} = $table;
  $args->{location} = $location;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_loadData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_loadData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub validateIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

    $self->send_validateIndex($table, $externalIndexPaths);
  $self->recv_validateIndex();
}

sub send_validateIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

  $self->{output}->writeMessageBegin('validateIndex', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_validateIndex_args();
  $args->{table} = $table;
  $args->{externalIndexPaths} = $externalIndexPaths;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_validateIndex{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_validateIndex_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub loadIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

    $self->send_loadIndex($table, $externalIndexPaths);
  $self->recv_loadIndex();
}

sub send_loadIndex{
  my $self = shift;
  my $table = shift;
  my $externalIndexPaths = shift;

  $self->{output}->writeMessageBegin('loadIndex', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_loadIndex_args();
  $args->{table} = $table;
  $args->{externalIndexPaths} = $externalIndexPaths;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_loadIndex{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_loadIndex_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub mutate{
  my $self = shift;
  my $mutation = shift;

    $self->send_mutate($mutation);
  $self->recv_mutate();
}

sub send_mutate{
  my $self = shift;
  my $mutation = shift;

  $self->{output}->writeMessageBegin('mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutate_args();
  $args->{mutation} = $mutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enqueueMutate{
  my $self = shift;
  my $mutation = shift;

    $self->send_enqueueMutate($mutation);
  $self->recv_enqueueMutate();
}

sub send_enqueueMutate{
  my $self = shift;
  my $mutation = shift;

  $self->{output}->writeMessageBegin('enqueueMutate', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enqueueMutate_args();
  $args->{mutation} = $mutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enqueueMutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enqueueMutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

    $self->send_mutateBatch($mutations);
  $self->recv_mutateBatch();
}

sub send_mutateBatch{
  my $self = shift;
  my $mutations = shift;

  $self->{output}->writeMessageBegin('mutateBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutateBatch_args();
  $args->{mutations} = $mutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutateBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enqueueMutateBatch{
  my $self = shift;
  my $mutations = shift;

    $self->send_enqueueMutateBatch($mutations);
  $self->recv_enqueueMutateBatch();
}

sub send_enqueueMutateBatch{
  my $self = shift;
  my $mutations = shift;

  $self->{output}->writeMessageBegin('enqueueMutateBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enqueueMutateBatch_args();
  $args->{mutations} = $mutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enqueueMutateBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enqueueMutateBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub bulkMutateStart{
  my $self = shift;
  my $bulkId = shift;

    $self->send_bulkMutateStart($bulkId);
  $self->recv_bulkMutateStart();
}

sub send_bulkMutateStart{
  my $self = shift;
  my $bulkId = shift;

  $self->{output}->writeMessageBegin('bulkMutateStart', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_bulkMutateStart_args();
  $args->{bulkId} = $bulkId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_bulkMutateStart{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_bulkMutateStart_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub bulkMutateAdd{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutation = shift;

    $self->send_bulkMutateAdd($bulkId, $rowMutation);
  $self->recv_bulkMutateAdd();
}

sub send_bulkMutateAdd{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutation = shift;

  $self->{output}->writeMessageBegin('bulkMutateAdd', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_bulkMutateAdd_args();
  $args->{bulkId} = $bulkId;
  $args->{rowMutation} = $rowMutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_bulkMutateAdd{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_bulkMutateAdd_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub bulkMutateAddMultiple{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutations = shift;

    $self->send_bulkMutateAddMultiple($bulkId, $rowMutations);
  $self->recv_bulkMutateAddMultiple();
}

sub send_bulkMutateAddMultiple{
  my $self = shift;
  my $bulkId = shift;
  my $rowMutations = shift;

  $self->{output}->writeMessageBegin('bulkMutateAddMultiple', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_bulkMutateAddMultiple_args();
  $args->{bulkId} = $bulkId;
  $args->{rowMutations} = $rowMutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_bulkMutateAddMultiple{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_bulkMutateAddMultiple_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub bulkMutateFinish{
  my $self = shift;
  my $bulkId = shift;
  my $apply = shift;
  my $blockUntilComplete = shift;

    $self->send_bulkMutateFinish($bulkId, $apply, $blockUntilComplete);
  $self->recv_bulkMutateFinish();
}

sub send_bulkMutateFinish{
  my $self = shift;
  my $bulkId = shift;
  my $apply = shift;
  my $blockUntilComplete = shift;

  $self->{output}->writeMessageBegin('bulkMutateFinish', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_bulkMutateFinish_args();
  $args->{bulkId} = $bulkId;
  $args->{apply} = $apply;
  $args->{blockUntilComplete} = $blockUntilComplete;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_bulkMutateFinish{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_bulkMutateFinish_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_cancelQuery($table, $uuid);
  $self->recv_cancelQuery();
}

sub send_cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('cancelQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_cancelQuery_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancelQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_cancelQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

    $self->send_queryStatusIdList($table);
  return $self->recv_queryStatusIdList();
}

sub send_queryStatusIdList{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('queryStatusIdList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusIdList_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusIdList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusIdList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusIdList failed: unknown result";
}
sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_queryStatusById($table, $uuid);
  return $self->recv_queryStatusById();
}

sub send_queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('queryStatusById', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusById_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusById{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusById_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusById failed: unknown result";
}
sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

    $self->send_terms($table, $columnFamily, $columnName, $startWith, $size);
  return $self->recv_terms();
}

sub send_terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  $self->{output}->writeMessageBegin('terms', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_terms_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{startWith} = $startWith;
  $args->{size} = $size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_terms{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_terms_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "terms failed: unknown result";
}
sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

    $self->send_recordFrequency($table, $columnFamily, $columnName, $value);
  return $self->recv_recordFrequency();
}

sub send_recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('recordFrequency', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_recordFrequency_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_recordFrequency{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_recordFrequency_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "recordFrequency failed: unknown result";
}
sub shardClusterList{
  my $self = shift;

    $self->send_shardClusterList();
  return $self->recv_shardClusterList();
}

sub send_shardClusterList{
  my $self = shift;

  $self->{output}->writeMessageBegin('shardClusterList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardClusterList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardClusterList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardClusterList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardClusterList failed: unknown result";
}
sub shardServerList{
  my $self = shift;
  my $cluster = shift;

    $self->send_shardServerList($cluster);
  return $self->recv_shardServerList();
}

sub send_shardServerList{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('shardServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerList_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerList failed: unknown result";
}
sub controllerServerList{
  my $self = shift;

    $self->send_controllerServerList();
  return $self->recv_controllerServerList();
}

sub send_controllerServerList{
  my $self = shift;

  $self->{output}->writeMessageBegin('controllerServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_controllerServerList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_controllerServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_controllerServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "controllerServerList failed: unknown result";
}
sub shardServerLayout{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayout($table);
  return $self->recv_shardServerLayout();
}

sub send_shardServerLayout{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayout', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayout_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayout{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayout_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayout failed: unknown result";
}
sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayoutState($table);
  return $self->recv_shardServerLayoutState();
}

sub send_shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayoutState', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayoutState_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayoutState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayoutState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayoutState failed: unknown result";
}
sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

    $self->send_isInSafeMode($cluster);
  return $self->recv_isInSafeMode();
}

sub send_isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('isInSafeMode', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_isInSafeMode_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isInSafeMode{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_isInSafeMode_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "isInSafeMode failed: unknown result";
}
sub configuration{
  my $self = shift;

    $self->send_configuration();
  return $self->recv_configuration();
}

sub send_configuration{
  my $self = shift;

  $self->{output}->writeMessageBegin('configuration', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_configuration_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_configuration{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_configuration_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "configuration failed: unknown result";
}
sub configurationPerServer{
  my $self = shift;
  my $thriftServerPlusPort = shift;
  my $configName = shift;

    $self->send_configurationPerServer($thriftServerPlusPort, $configName);
  return $self->recv_configurationPerServer();
}

sub send_configurationPerServer{
  my $self = shift;
  my $thriftServerPlusPort = shift;
  my $configName = shift;

  $self->{output}->writeMessageBegin('configurationPerServer', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_configurationPerServer_args();
  $args->{thriftServerPlusPort} = $thriftServerPlusPort;
  $args->{configName} = $configName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_configurationPerServer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_configurationPerServer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "configurationPerServer failed: unknown result";
}
sub metrics{
  my $self = shift;
  my $metrics = shift;

    $self->send_metrics($metrics);
  return $self->recv_metrics();
}

sub send_metrics{
  my $self = shift;
  my $metrics = shift;

  $self->{output}->writeMessageBegin('metrics', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_metrics_args();
  $args->{metrics} = $metrics;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_metrics{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_metrics_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "metrics failed: unknown result";
}
sub startTrace{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

    $self->send_startTrace($traceId, $requestId);
}

sub send_startTrace{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

  $self->{output}->writeMessageBegin('startTrace', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_startTrace_args();
  $args->{traceId} = $traceId;
  $args->{requestId} = $requestId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub traceList{
  my $self = shift;

    $self->send_traceList();
  return $self->recv_traceList();
}

sub send_traceList{
  my $self = shift;

  $self->{output}->writeMessageBegin('traceList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_traceList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_traceList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_traceList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "traceList failed: unknown result";
}
sub traceRequestList{
  my $self = shift;
  my $traceId = shift;

    $self->send_traceRequestList($traceId);
  return $self->recv_traceRequestList();
}

sub send_traceRequestList{
  my $self = shift;
  my $traceId = shift;

  $self->{output}->writeMessageBegin('traceRequestList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_traceRequestList_args();
  $args->{traceId} = $traceId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_traceRequestList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_traceRequestList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "traceRequestList failed: unknown result";
}
sub traceRequestFetch{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

    $self->send_traceRequestFetch($traceId, $requestId);
  return $self->recv_traceRequestFetch();
}

sub send_traceRequestFetch{
  my $self = shift;
  my $traceId = shift;
  my $requestId = shift;

  $self->{output}->writeMessageBegin('traceRequestFetch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_traceRequestFetch_args();
  $args->{traceId} = $traceId;
  $args->{requestId} = $requestId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_traceRequestFetch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_traceRequestFetch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "traceRequestFetch failed: unknown result";
}
sub traceRemove{
  my $self = shift;
  my $traceId = shift;

    $self->send_traceRemove($traceId);
  $self->recv_traceRemove();
}

sub send_traceRemove{
  my $self = shift;
  my $traceId = shift;

  $self->{output}->writeMessageBegin('traceRemove', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_traceRemove_args();
  $args->{traceId} = $traceId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_traceRemove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_traceRemove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub ping{
  my $self = shift;

    $self->send_ping();
  $self->recv_ping();
}

sub send_ping{
  my $self = shift;

  $self->{output}->writeMessageBegin('ping', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_ping_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ping{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_ping_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub logging{
  my $self = shift;
  my $classNameOrLoggerName = shift;
  my $level = shift;

    $self->send_logging($classNameOrLoggerName, $level);
  $self->recv_logging();
}

sub send_logging{
  my $self = shift;
  my $classNameOrLoggerName = shift;
  my $level = shift;

  $self->{output}->writeMessageBegin('logging', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_logging_args();
  $args->{classNameOrLoggerName} = $classNameOrLoggerName;
  $args->{level} = $level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_logging{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_logging_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub resetLogging{
  my $self = shift;

    $self->send_resetLogging();
  $self->recv_resetLogging();
}

sub send_resetLogging{
  my $self = shift;

  $self->{output}->writeMessageBegin('resetLogging', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_resetLogging_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_resetLogging{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_resetLogging_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
package Blur::BlurProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_listInstalledCommands {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_listInstalledCommands_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_listInstalledCommands_result();
    eval {
      $result->{success} = $self->{handler}->listInstalledCommands();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('listInstalledCommands', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_execute_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_execute_result();
    eval {
      $result->{success} = $self->{handler}->execute($args->commandName, $args->arguments);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{bex} = $@;
        }; if( UNIVERSAL::isa($@,'Blur::TimeoutException') ){ 
      $result->{tex} = $@;
    }
    $output->writeMessageBegin('execute', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_reconnect {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_reconnect_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_reconnect_result();
    eval {
      $result->{success} = $self->{handler}->reconnect($args->instanceExecutionId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{bex} = $@;
        }; if( UNIVERSAL::isa($@,'Blur::TimeoutException') ){ 
      $result->{tex} = $@;
    }
    $output->writeMessageBegin('reconnect', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_commandStatusList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_commandStatusList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_commandStatusList_result();
    eval {
      $result->{success} = $self->{handler}->commandStatusList($args->startingAt, $args->fetch, $args->state);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('commandStatusList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_commandStatus {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_commandStatus_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_commandStatus_result();
    eval {
      $result->{success} = $self->{handler}->commandStatus($args->commandExecutionId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('commandStatus', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_commandCancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_commandCancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_commandCancel_result();
    eval {
      $self->{handler}->commandCancel($args->commandExecutionId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('commandCancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refresh {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_refresh_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->refresh();
    return;
}
sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableDescriptor);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeTable_result();
    eval {
      $self->{handler}->removeTable($args->table, $args->deleteIndexFiles);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_addColumnDefinition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_addColumnDefinition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_addColumnDefinition_result();
    eval {
      $result->{success} = $self->{handler}->addColumnDefinition($args->table, $args->columnDefinition);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('addColumnDefinition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableList_result();
    eval {
      $result->{success} = $self->{handler}->tableList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableListByCluster {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableListByCluster_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableListByCluster_result();
    eval {
      $result->{success} = $self->{handler}->tableListByCluster($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableListByCluster', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_describe_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_describe_result();
    eval {
      $result->{success} = $self->{handler}->describe($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('describe', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_schema_result();
    eval {
      $result->{success} = $self->{handler}->schema($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_parseQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_parseQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_parseQuery_result();
    eval {
      $result->{success} = $self->{handler}->parseQuery($args->table, $args->query);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('parseQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableStats {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableStats_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableStats_result();
    eval {
      $result->{success} = $self->{handler}->tableStats($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableStats', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_optimize {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_optimize_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_optimize_result();
    eval {
      $self->{handler}->optimize($args->table, $args->numberOfSegmentsPerShard);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('optimize', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createSnapshot {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createSnapshot_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createSnapshot_result();
    eval {
      $self->{handler}->createSnapshot($args->table, $args->name);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createSnapshot', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeSnapshot {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeSnapshot_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeSnapshot_result();
    eval {
      $self->{handler}->removeSnapshot($args->table, $args->name);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeSnapshot', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listSnapshots {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_listSnapshots_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_listSnapshots_result();
    eval {
      $result->{success} = $self->{handler}->listSnapshots($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('listSnapshots', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_setUser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_setUser_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->setUser($args->user);
    return;
}
sub process_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_query_result();
    eval {
      $result->{success} = $self->{handler}->query($args->table, $args->blurQuery);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRow_result();
    eval {
      $result->{success} = $self->{handler}->fetchRow($args->table, $args->selector);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRowBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRowBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRowBatch_result();
    eval {
      $result->{success} = $self->{handler}->fetchRowBatch($args->table, $args->selectors);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRowBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_loadData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_loadData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_loadData_result();
    eval {
      $self->{handler}->loadData($args->table, $args->location);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('loadData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_validateIndex {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_validateIndex_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_validateIndex_result();
    eval {
      $self->{handler}->validateIndex($args->table, $args->externalIndexPaths);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('validateIndex', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_loadIndex {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_loadIndex_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_loadIndex_result();
    eval {
      $self->{handler}->loadIndex($args->table, $args->externalIndexPaths);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('loadIndex', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutate_result();
    eval {
      $self->{handler}->mutate($args->mutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enqueueMutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enqueueMutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enqueueMutate_result();
    eval {
      $self->{handler}->enqueueMutate($args->mutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enqueueMutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutateBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutateBatch_result();
    eval {
      $self->{handler}->mutateBatch($args->mutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutateBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enqueueMutateBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enqueueMutateBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enqueueMutateBatch_result();
    eval {
      $self->{handler}->enqueueMutateBatch($args->mutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enqueueMutateBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_bulkMutateStart {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_bulkMutateStart_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_bulkMutateStart_result();
    eval {
      $self->{handler}->bulkMutateStart($args->bulkId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('bulkMutateStart', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_bulkMutateAdd {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_bulkMutateAdd_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_bulkMutateAdd_result();
    eval {
      $self->{handler}->bulkMutateAdd($args->bulkId, $args->rowMutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('bulkMutateAdd', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_bulkMutateAddMultiple {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_bulkMutateAddMultiple_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_bulkMutateAddMultiple_result();
    eval {
      $self->{handler}->bulkMutateAddMultiple($args->bulkId, $args->rowMutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('bulkMutateAddMultiple', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_bulkMutateFinish {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_bulkMutateFinish_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_bulkMutateFinish_result();
    eval {
      $self->{handler}->bulkMutateFinish($args->bulkId, $args->apply, $args->blockUntilComplete);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('bulkMutateFinish', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancelQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_cancelQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_cancelQuery_result();
    eval {
      $self->{handler}->cancelQuery($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('cancelQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusIdList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusIdList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusIdList_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusIdList($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusIdList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusById {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusById_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusById_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusById($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusById', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_terms {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_terms_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_terms_result();
    eval {
      $result->{success} = $self->{handler}->terms($args->table, $args->columnFamily, $args->columnName, $args->startWith, $args->size);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('terms', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_recordFrequency {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_recordFrequency_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_recordFrequency_result();
    eval {
      $result->{success} = $self->{handler}->recordFrequency($args->table, $args->columnFamily, $args->columnName, $args->value);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('recordFrequency', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardClusterList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardClusterList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardClusterList_result();
    eval {
      $result->{success} = $self->{handler}->shardClusterList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardClusterList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerList_result();
    eval {
      $result->{success} = $self->{handler}->shardServerList($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_controllerServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_controllerServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_controllerServerList_result();
    eval {
      $result->{success} = $self->{handler}->controllerServerList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('controllerServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayout {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayout_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayout_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayout($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayout', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayoutState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayoutState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayoutState_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayoutState($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayoutState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isInSafeMode {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_isInSafeMode_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_isInSafeMode_result();
    eval {
      $result->{success} = $self->{handler}->isInSafeMode($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('isInSafeMode', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_configuration {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_configuration_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_configuration_result();
    eval {
      $result->{success} = $self->{handler}->configuration();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('configuration', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_configurationPerServer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_configurationPerServer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_configurationPerServer_result();
    eval {
      $result->{success} = $self->{handler}->configurationPerServer($args->thriftServerPlusPort, $args->configName);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('configurationPerServer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_metrics {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_metrics_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_metrics_result();
    eval {
      $result->{success} = $self->{handler}->metrics($args->metrics);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('metrics', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_startTrace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_startTrace_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->startTrace($args->traceId, $args->requestId);
    return;
}
sub process_traceList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_traceList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_traceList_result();
    eval {
      $result->{success} = $self->{handler}->traceList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('traceList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_traceRequestList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_traceRequestList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_traceRequestList_result();
    eval {
      $result->{success} = $self->{handler}->traceRequestList($args->traceId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('traceRequestList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_traceRequestFetch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_traceRequestFetch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_traceRequestFetch_result();
    eval {
      $result->{success} = $self->{handler}->traceRequestFetch($args->traceId, $args->requestId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('traceRequestFetch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_traceRemove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_traceRemove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_traceRemove_result();
    eval {
      $self->{handler}->traceRemove($args->traceId);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('traceRemove', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ping {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_ping_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_ping_result();
    $self->{handler}->ping();
    $output->writeMessageBegin('ping', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_logging {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_logging_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_logging_result();
    eval {
      $self->{handler}->logging($args->classNameOrLoggerName, $args->level);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('logging', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_resetLogging {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_resetLogging_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_resetLogging_result();
    eval {
      $self->{handler}->resetLogging();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('resetLogging', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;

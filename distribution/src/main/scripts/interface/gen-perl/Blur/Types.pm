#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Blur::ErrorType;
use constant UNKNOWN => 0;
use constant QUERY_CANCEL => 1;
use constant QUERY_TIMEOUT => 2;
use constant BACK_PRESSURE => 3;
use constant REQUEST_TIMEOUT => 4;
package Blur::ScoreType;
use constant SUPER => 0;
use constant AGGREGATE => 1;
use constant BEST => 2;
use constant CONSTANT => 3;
package Blur::QueryState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
use constant BACK_PRESSURE_INTERRUPTED => 3;
package Blur::Status;
use constant NOT_FOUND => 0;
use constant FOUND => 1;
package Blur::RowMutationType;
use constant DELETE_ROW => 0;
use constant REPLACE_ROW => 1;
use constant UPDATE_ROW => 2;
package Blur::RecordMutationType;
use constant DELETE_ENTIRE_RECORD => 0;
use constant REPLACE_ENTIRE_RECORD => 1;
use constant REPLACE_COLUMNS => 2;
use constant APPEND_COLUMN_VALUES => 3;
package Blur::ShardState;
use constant OPENING => 0;
use constant OPEN => 1;
use constant OPENING_ERROR => 2;
use constant CLOSING => 3;
use constant CLOSED => 4;
use constant CLOSING_ERROR => 5;
package Blur::Level;
use constant OFF => 0;
use constant FATAL => 1;
use constant ERROR => 2;
use constant WARN => 3;
use constant INFO => 4;
use constant DEBUG => 5;
use constant TRACE => 6;
use constant ALL => 7;
package Blur::BlurObjectType;
use constant MAP => 0;
use constant LIST => 1;
use constant NAME => 2;
use constant VALUE => 3;
package Blur::CommandStatusState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
use constant BACK_PRESSURE_INTERRUPTED => 3;
package Blur::BlurException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::BlurException->mk_accessors( qw( message stackTraceStr errorType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stackTraceStr} = undef;
  $self->{errorType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stackTraceStr}) {
      $self->{stackTraceStr} = $vals->{stackTraceStr};
    }
    if (defined $vals->{errorType}) {
      $self->{errorType} = $vals->{errorType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stackTraceStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stackTraceStr}) {
    $xfer += $output->writeFieldBegin('stackTraceStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{stackTraceStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{errorType}) {
    $xfer += $output->writeFieldBegin('errorType', TType::I32, 3);
    $xfer += $output->writeI32($self->{errorType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TimeoutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::TimeoutException->mk_accessors( qw( instanceExecutionId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{instanceExecutionId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{instanceExecutionId}) {
      $self->{instanceExecutionId} = $vals->{instanceExecutionId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TimeoutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{instanceExecutionId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimeoutException');
  if (defined $self->{instanceExecutionId}) {
    $xfer += $output->writeFieldBegin('instanceExecutionId', TType::I64, 1);
    $xfer += $output->writeI64($self->{instanceExecutionId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::User;
use base qw(Class::Accessor);
Blur::User->mk_accessors( qw( username attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'User';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{attributes} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = '';
            my $val6 = '';
            $xfer += $input->readString(\$key5);
            $xfer += $input->readString(\$val6);
            $self->{attributes}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('User');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter7,$viter8) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter7);
          $xfer += $output->writeString($viter8);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Column;
use base qw(Class::Accessor);
Blur::Column->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Record;
use base qw(Class::Accessor);
Blur::Record->mk_accessors( qw( recordId family columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordId} = undef;
  $self->{family} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Record';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size9 = 0;
          $self->{columns} = [];
          my $_etype12 = 0;
          $xfer += $input->readListBegin(\$_etype12, \$_size9);
          for (my $_i13 = 0; $_i13 < $_size9; ++$_i13)
          {
            my $elem14 = undef;
            $elem14 = new Blur::Column();
            $xfer += $elem14->read($input);
            push(@{$self->{columns}},$elem14);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Record');
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 1);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 2);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter15 (@{$self->{columns}}) 
        {
          $xfer += ${iter15}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Row;
use base qw(Class::Accessor);
Blur::Row->mk_accessors( qw( id records ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{records} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{records}) {
      $self->{records} = $vals->{records};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Row';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size16 = 0;
          $self->{records} = [];
          my $_etype19 = 0;
          $xfer += $input->readListBegin(\$_etype19, \$_size16);
          for (my $_i20 = 0; $_i20 < $_size16; ++$_i20)
          {
            my $elem21 = undef;
            $elem21 = new Blur::Record();
            $xfer += $elem21->read($input);
            push(@{$self->{records}},$elem21);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Row');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{records}) {
    $xfer += $output->writeFieldBegin('records', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{records}}));
      {
        foreach my $iter22 (@{$self->{records}}) 
        {
          $xfer += ${iter22}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Query;
use base qw(Class::Accessor);
Blur::Query->mk_accessors( qw( query rowQuery scoreType rowFilter recordFilter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{rowQuery} = 1;
  $self->{scoreType} = 0;
  $self->{rowFilter} = undef;
  $self->{recordFilter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{rowQuery}) {
      $self->{rowQuery} = $vals->{rowQuery};
    }
    if (defined $vals->{scoreType}) {
      $self->{scoreType} = $vals->{scoreType};
    }
    if (defined $vals->{rowFilter}) {
      $self->{rowFilter} = $vals->{rowFilter};
    }
    if (defined $vals->{recordFilter}) {
      $self->{recordFilter} = $vals->{recordFilter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Query';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{rowQuery});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{scoreType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Query');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowQuery}) {
    $xfer += $output->writeFieldBegin('rowQuery', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{rowQuery});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scoreType}) {
    $xfer += $output->writeFieldBegin('scoreType', TType::I32, 3);
    $xfer += $output->writeI32($self->{scoreType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowFilter}) {
    $xfer += $output->writeFieldBegin('rowFilter', TType::STRING, 4);
    $xfer += $output->writeString($self->{rowFilter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordFilter}) {
    $xfer += $output->writeFieldBegin('recordFilter', TType::STRING, 5);
    $xfer += $output->writeString($self->{recordFilter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::HighlightOptions;
use base qw(Class::Accessor);
Blur::HighlightOptions->mk_accessors( qw( query preTag postTag ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{preTag} = "<<<";
  $self->{postTag} = ">>>";
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{preTag}) {
      $self->{preTag} = $vals->{preTag};
    }
    if (defined $vals->{postTag}) {
      $self->{postTag} = $vals->{postTag};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HighlightOptions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::Query();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preTag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postTag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HighlightOptions');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preTag}) {
    $xfer += $output->writeFieldBegin('preTag', TType::STRING, 2);
    $xfer += $output->writeString($self->{preTag});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postTag}) {
    $xfer += $output->writeFieldBegin('postTag', TType::STRING, 3);
    $xfer += $output->writeString($self->{postTag});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Selector;
use base qw(Class::Accessor);
Blur::Selector->mk_accessors( qw( recordOnly locationId rowId recordId columnFamiliesToFetch columnsToFetch startRecord maxRecordsToFetch highlightOptions orderOfFamiliesToFetch ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordOnly} = undef;
  $self->{locationId} = undef;
  $self->{rowId} = undef;
  $self->{recordId} = undef;
  $self->{columnFamiliesToFetch} = undef;
  $self->{columnsToFetch} = undef;
  $self->{startRecord} = 0;
  $self->{maxRecordsToFetch} = 1000;
  $self->{highlightOptions} = undef;
  $self->{orderOfFamiliesToFetch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordOnly}) {
      $self->{recordOnly} = $vals->{recordOnly};
    }
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{columnFamiliesToFetch}) {
      $self->{columnFamiliesToFetch} = $vals->{columnFamiliesToFetch};
    }
    if (defined $vals->{columnsToFetch}) {
      $self->{columnsToFetch} = $vals->{columnsToFetch};
    }
    if (defined $vals->{startRecord}) {
      $self->{startRecord} = $vals->{startRecord};
    }
    if (defined $vals->{maxRecordsToFetch}) {
      $self->{maxRecordsToFetch} = $vals->{maxRecordsToFetch};
    }
    if (defined $vals->{highlightOptions}) {
      $self->{highlightOptions} = $vals->{highlightOptions};
    }
    if (defined $vals->{orderOfFamiliesToFetch}) {
      $self->{orderOfFamiliesToFetch} = $vals->{orderOfFamiliesToFetch};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Selector';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recordOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size23 = 0;
          $self->{columnFamiliesToFetch} = {};
          my $_etype26 = 0;
          $xfer += $input->readSetBegin(\$_etype26, \$_size23);
          for (my $_i27 = 0; $_i27 < $_size23; ++$_i27)
          {
            my $elem28 = undef;
            $xfer += $input->readString(\$elem28);
            $self->{columnFamiliesToFetch}->{$elem28} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size29 = 0;
          $self->{columnsToFetch} = {};
          my $_ktype30 = 0;
          my $_vtype31 = 0;
          $xfer += $input->readMapBegin(\$_ktype30, \$_vtype31, \$_size29);
          for (my $_i33 = 0; $_i33 < $_size29; ++$_i33)
          {
            my $key34 = '';
            my $val35 = [];
            $xfer += $input->readString(\$key34);
            {
              my $_size36 = 0;
              $val35 = {};
              my $_etype39 = 0;
              $xfer += $input->readSetBegin(\$_etype39, \$_size36);
              for (my $_i40 = 0; $_i40 < $_size36; ++$_i40)
              {
                my $elem41 = undef;
                $xfer += $input->readString(\$elem41);
                $val35->{$elem41} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnsToFetch}->{$key34} = $val35;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startRecord});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxRecordsToFetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{highlightOptions} = new Blur::HighlightOptions();
        $xfer += $self->{highlightOptions}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{orderOfFamiliesToFetch} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{orderOfFamiliesToFetch}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Selector');
  if (defined $self->{recordOnly}) {
    $xfer += $output->writeFieldBegin('recordOnly', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{recordOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 2);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 3);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 4);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('columnFamiliesToFetch', TType::SET, 5);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{columnFamiliesToFetch}}));
      {
        foreach my $iter48 (@{$self->{columnFamiliesToFetch}})
        {
          $xfer += $output->writeString($iter48);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToFetch}) {
    $xfer += $output->writeFieldBegin('columnsToFetch', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnsToFetch}}));
      {
        while( my ($kiter49,$viter50) = each %{$self->{columnsToFetch}}) 
        {
          $xfer += $output->writeString($kiter49);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter50}}));
            {
              foreach my $iter51 (@{${viter50}})
              {
                $xfer += $output->writeString($iter51);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRecord}) {
    $xfer += $output->writeFieldBegin('startRecord', TType::I32, 8);
    $xfer += $output->writeI32($self->{startRecord});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRecordsToFetch}) {
    $xfer += $output->writeFieldBegin('maxRecordsToFetch', TType::I32, 9);
    $xfer += $output->writeI32($self->{maxRecordsToFetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{highlightOptions}) {
    $xfer += $output->writeFieldBegin('highlightOptions', TType::STRUCT, 10);
    $xfer += $self->{highlightOptions}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{orderOfFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('orderOfFamiliesToFetch', TType::LIST, 11);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{orderOfFamiliesToFetch}}));
      {
        foreach my $iter52 (@{$self->{orderOfFamiliesToFetch}}) 
        {
          $xfer += $output->writeString($iter52);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRowResult;
use base qw(Class::Accessor);
Blur::FetchRowResult->mk_accessors( qw( row startRecord maxRecordsToFetch moreRecordsToFetch totalRecords ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{startRecord} = -1;
  $self->{maxRecordsToFetch} = -1;
  $self->{moreRecordsToFetch} = 0;
  $self->{totalRecords} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{startRecord}) {
      $self->{startRecord} = $vals->{startRecord};
    }
    if (defined $vals->{maxRecordsToFetch}) {
      $self->{maxRecordsToFetch} = $vals->{maxRecordsToFetch};
    }
    if (defined $vals->{moreRecordsToFetch}) {
      $self->{moreRecordsToFetch} = $vals->{moreRecordsToFetch};
    }
    if (defined $vals->{totalRecords}) {
      $self->{totalRecords} = $vals->{totalRecords};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRowResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{row} = new Blur::Row();
        $xfer += $self->{row}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startRecord});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxRecordsToFetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{moreRecordsToFetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalRecords});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRowResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRUCT, 1);
    $xfer += $self->{row}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRecord}) {
    $xfer += $output->writeFieldBegin('startRecord', TType::I32, 2);
    $xfer += $output->writeI32($self->{startRecord});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRecordsToFetch}) {
    $xfer += $output->writeFieldBegin('maxRecordsToFetch', TType::I32, 3);
    $xfer += $output->writeI32($self->{maxRecordsToFetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{moreRecordsToFetch}) {
    $xfer += $output->writeFieldBegin('moreRecordsToFetch', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{moreRecordsToFetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalRecords}) {
    $xfer += $output->writeFieldBegin('totalRecords', TType::I32, 5);
    $xfer += $output->writeI32($self->{totalRecords});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRecordResult;
use base qw(Class::Accessor);
Blur::FetchRecordResult->mk_accessors( qw( rowid record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{rowid} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{rowid}) {
      $self->{rowid} = $vals->{rowid};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRecordResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRecordResult');
  if (defined $self->{rowid}) {
    $xfer += $output->writeFieldBegin('rowid', TType::STRING, 1);
    $xfer += $output->writeString($self->{rowid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchResult;
use base qw(Class::Accessor);
Blur::FetchResult->mk_accessors( qw( exists deleted table rowResult recordResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{exists} = undef;
  $self->{deleted} = undef;
  $self->{table} = undef;
  $self->{rowResult} = undef;
  $self->{recordResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{exists}) {
      $self->{exists} = $vals->{exists};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowResult}) {
      $self->{rowResult} = $vals->{rowResult};
    }
    if (defined $vals->{recordResult}) {
      $self->{recordResult} = $vals->{recordResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowResult} = new Blur::FetchRowResult();
        $xfer += $self->{rowResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{recordResult} = new Blur::FetchRecordResult();
        $xfer += $self->{recordResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchResult');
  if (defined $self->{exists}) {
    $xfer += $output->writeFieldBegin('exists', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{exists});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowResult}) {
    $xfer += $output->writeFieldBegin('rowResult', TType::STRUCT, 4);
    $xfer += $self->{rowResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordResult}) {
    $xfer += $output->writeFieldBegin('recordResult', TType::STRUCT, 5);
    $xfer += $self->{recordResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Facet;
use base qw(Class::Accessor);
Blur::Facet->mk_accessors( qw( queryStr minimumNumberOfBlurResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{minimumNumberOfBlurResults} = 9223372036854775807;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{minimumNumberOfBlurResults}) {
      $self->{minimumNumberOfBlurResults} = $vals->{minimumNumberOfBlurResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Facet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfBlurResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Facet');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfBlurResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfBlurResults', TType::I64, 2);
    $xfer += $output->writeI64($self->{minimumNumberOfBlurResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SortField;
use base qw(Class::Accessor);
Blur::SortField->mk_accessors( qw( family column reverse ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{column} = undef;
  $self->{reverse} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{reverse}) {
      $self->{reverse} = $vals->{reverse};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SortField';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{reverse});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SortField');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 2);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reverse}) {
    $xfer += $output->writeFieldBegin('reverse', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reverse});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQuery;
use base qw(Class::Accessor);
Blur::BlurQuery->mk_accessors( qw( query facets selector useCacheIfPresent start fetch minimumNumberOfResults maxQueryTime uuid userContext cacheResult startTime sortFields rowId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{facets} = undef;
  $self->{selector} = undef;
  $self->{useCacheIfPresent} = 1;
  $self->{start} = 0;
  $self->{fetch} = 10;
  $self->{minimumNumberOfResults} = 9223372036854775807;
  $self->{maxQueryTime} = 9223372036854775807;
  $self->{uuid} = undef;
  $self->{userContext} = undef;
  $self->{cacheResult} = 1;
  $self->{startTime} = 0;
  $self->{sortFields} = undef;
  $self->{rowId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{facets}) {
      $self->{facets} = $vals->{facets};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
    if (defined $vals->{useCacheIfPresent}) {
      $self->{useCacheIfPresent} = $vals->{useCacheIfPresent};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{minimumNumberOfResults}) {
      $self->{minimumNumberOfResults} = $vals->{minimumNumberOfResults};
    }
    if (defined $vals->{maxQueryTime}) {
      $self->{maxQueryTime} = $vals->{maxQueryTime};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{userContext}) {
      $self->{userContext} = $vals->{userContext};
    }
    if (defined $vals->{cacheResult}) {
      $self->{cacheResult} = $vals->{cacheResult};
    }
    if (defined $vals->{startTime}) {
      $self->{startTime} = $vals->{startTime};
    }
    if (defined $vals->{sortFields}) {
      $self->{sortFields} = $vals->{sortFields};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::Query();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size53 = 0;
          $self->{facets} = [];
          my $_etype56 = 0;
          $xfer += $input->readListBegin(\$_etype56, \$_size53);
          for (my $_i57 = 0; $_i57 < $_size53; ++$_i57)
          {
            my $elem58 = undef;
            $elem58 = new Blur::Facet();
            $xfer += $elem58->read($input);
            push(@{$self->{facets}},$elem58);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{useCacheIfPresent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxQueryTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userContext});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cacheResult});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size59 = 0;
          $self->{sortFields} = [];
          my $_etype62 = 0;
          $xfer += $input->readListBegin(\$_etype62, \$_size59);
          for (my $_i63 = 0; $_i63 < $_size59; ++$_i63)
          {
            my $elem64 = undef;
            $elem64 = new Blur::SortField();
            $xfer += $elem64->read($input);
            push(@{$self->{sortFields}},$elem64);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQuery');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facets}) {
    $xfer += $output->writeFieldBegin('facets', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{facets}}));
      {
        foreach my $iter65 (@{$self->{facets}}) 
        {
          $xfer += ${iter65}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 4);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{useCacheIfPresent}) {
    $xfer += $output->writeFieldBegin('useCacheIfPresent', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{useCacheIfPresent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 7);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I32, 8);
    $xfer += $output->writeI32($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfResults', TType::I64, 9);
    $xfer += $output->writeI64($self->{minimumNumberOfResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxQueryTime}) {
    $xfer += $output->writeFieldBegin('maxQueryTime', TType::I64, 10);
    $xfer += $output->writeI64($self->{maxQueryTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 11);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userContext}) {
    $xfer += $output->writeFieldBegin('userContext', TType::STRING, 12);
    $xfer += $output->writeString($self->{userContext});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cacheResult}) {
    $xfer += $output->writeFieldBegin('cacheResult', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{cacheResult});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startTime}) {
    $xfer += $output->writeFieldBegin('startTime', TType::I64, 14);
    $xfer += $output->writeI64($self->{startTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sortFields}) {
    $xfer += $output->writeFieldBegin('sortFields', TType::LIST, 15);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sortFields}}));
      {
        foreach my $iter66 (@{$self->{sortFields}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 16);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SortFieldResult;
use base qw(Class::Accessor);
Blur::SortFieldResult->mk_accessors( qw( nullValue stringValue intValue longValue doubleValue binaryValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{nullValue} = undef;
  $self->{stringValue} = undef;
  $self->{intValue} = undef;
  $self->{longValue} = undef;
  $self->{doubleValue} = undef;
  $self->{binaryValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{nullValue}) {
      $self->{nullValue} = $vals->{nullValue};
    }
    if (defined $vals->{stringValue}) {
      $self->{stringValue} = $vals->{stringValue};
    }
    if (defined $vals->{intValue}) {
      $self->{intValue} = $vals->{intValue};
    }
    if (defined $vals->{longValue}) {
      $self->{longValue} = $vals->{longValue};
    }
    if (defined $vals->{doubleValue}) {
      $self->{doubleValue} = $vals->{doubleValue};
    }
    if (defined $vals->{binaryValue}) {
      $self->{binaryValue} = $vals->{binaryValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SortFieldResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{nullValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stringValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{intValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{longValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{doubleValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{binaryValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SortFieldResult');
  if (defined $self->{nullValue}) {
    $xfer += $output->writeFieldBegin('nullValue', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{nullValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stringValue}) {
    $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 2);
    $xfer += $output->writeString($self->{stringValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{intValue}) {
    $xfer += $output->writeFieldBegin('intValue', TType::I32, 3);
    $xfer += $output->writeI32($self->{intValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{longValue}) {
    $xfer += $output->writeFieldBegin('longValue', TType::I64, 4);
    $xfer += $output->writeI64($self->{longValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleValue}) {
    $xfer += $output->writeFieldBegin('doubleValue', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{doubleValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{binaryValue}) {
    $xfer += $output->writeFieldBegin('binaryValue', TType::STRING, 6);
    $xfer += $output->writeString($self->{binaryValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResult;
use base qw(Class::Accessor);
Blur::BlurResult->mk_accessors( qw( locationId score fetchResult sortFieldResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locationId} = undef;
  $self->{score} = undef;
  $self->{fetchResult} = undef;
  $self->{sortFieldResults} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{fetchResult}) {
      $self->{fetchResult} = $vals->{fetchResult};
    }
    if (defined $vals->{sortFieldResults}) {
      $self->{sortFieldResults} = $vals->{sortFieldResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{fetchResult} = new Blur::FetchResult();
        $xfer += $self->{fetchResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size67 = 0;
          $self->{sortFieldResults} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = new Blur::SortFieldResult();
            $xfer += $elem72->read($input);
            push(@{$self->{sortFieldResults}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResult');
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 1);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetchResult}) {
    $xfer += $output->writeFieldBegin('fetchResult', TType::STRUCT, 3);
    $xfer += $self->{fetchResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sortFieldResults}) {
    $xfer += $output->writeFieldBegin('sortFieldResults', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sortFieldResults}}));
      {
        foreach my $iter73 (@{$self->{sortFieldResults}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResults;
use base qw(Class::Accessor);
Blur::BlurResults->mk_accessors( qw( totalResults shardInfo results facetCounts exceptions query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{totalResults} = 0;
  $self->{shardInfo} = undef;
  $self->{results} = undef;
  $self->{facetCounts} = undef;
  $self->{exceptions} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{totalResults}) {
      $self->{totalResults} = $vals->{totalResults};
    }
    if (defined $vals->{shardInfo}) {
      $self->{shardInfo} = $vals->{shardInfo};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
    if (defined $vals->{facetCounts}) {
      $self->{facetCounts} = $vals->{facetCounts};
    }
    if (defined $vals->{exceptions}) {
      $self->{exceptions} = $vals->{exceptions};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResults';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{totalResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size74 = 0;
          $self->{shardInfo} = {};
          my $_ktype75 = 0;
          my $_vtype76 = 0;
          $xfer += $input->readMapBegin(\$_ktype75, \$_vtype76, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $key79 = '';
            my $val80 = 0;
            $xfer += $input->readString(\$key79);
            $xfer += $input->readI64(\$val80);
            $self->{shardInfo}->{$key79} = $val80;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{results} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Blur::BlurResult();
            $xfer += $elem86->read($input);
            push(@{$self->{results}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size87 = 0;
          $self->{facetCounts} = [];
          my $_etype90 = 0;
          $xfer += $input->readListBegin(\$_etype90, \$_size87);
          for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
          {
            my $elem92 = undef;
            $xfer += $input->readI64(\$elem92);
            push(@{$self->{facetCounts}},$elem92);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size93 = 0;
          $self->{exceptions} = [];
          my $_etype96 = 0;
          $xfer += $input->readListBegin(\$_etype96, \$_size93);
          for (my $_i97 = 0; $_i97 < $_size93; ++$_i97)
          {
            my $elem98 = undef;
            $elem98 = new Blur::BlurException();
            $xfer += $elem98->read($input);
            push(@{$self->{exceptions}},$elem98);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResults');
  if (defined $self->{totalResults}) {
    $xfer += $output->writeFieldBegin('totalResults', TType::I64, 1);
    $xfer += $output->writeI64($self->{totalResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardInfo}) {
    $xfer += $output->writeFieldBegin('shardInfo', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{shardInfo}}));
      {
        while( my ($kiter99,$viter100) = each %{$self->{shardInfo}}) 
        {
          $xfer += $output->writeString($kiter99);
          $xfer += $output->writeI64($viter100);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter101 (@{$self->{results}}) 
        {
          $xfer += ${iter101}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facetCounts}) {
    $xfer += $output->writeFieldBegin('facetCounts', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{facetCounts}}));
      {
        foreach my $iter102 (@{$self->{facetCounts}}) 
        {
          $xfer += $output->writeI64($iter102);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exceptions}) {
    $xfer += $output->writeFieldBegin('exceptions', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{exceptions}}));
      {
        foreach my $iter103 (@{$self->{exceptions}}) 
        {
          $xfer += ${iter103}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 6);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RecordMutation;
use base qw(Class::Accessor);
Blur::RecordMutation->mk_accessors( qw( recordMutationType record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordMutationType} = 1;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordMutationType}) {
      $self->{recordMutationType} = $vals->{recordMutationType};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecordMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecordMutation');
  if (defined $self->{recordMutationType}) {
    $xfer += $output->writeFieldBegin('recordMutationType', TType::I32, 1);
    $xfer += $output->writeI32($self->{recordMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RowMutation;
use base qw(Class::Accessor);
Blur::RowMutation->mk_accessors( qw( table rowId rowMutationType recordMutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{rowId} = undef;
  $self->{rowMutationType} = 1;
  $self->{recordMutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{rowMutationType}) {
      $self->{rowMutationType} = $vals->{rowMutationType};
    }
    if (defined $vals->{recordMutations}) {
      $self->{recordMutations} = $vals->{recordMutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{rowMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size104 = 0;
          $self->{recordMutations} = [];
          my $_etype107 = 0;
          $xfer += $input->readListBegin(\$_etype107, \$_size104);
          for (my $_i108 = 0; $_i108 < $_size104; ++$_i108)
          {
            my $elem109 = undef;
            $elem109 = new Blur::RecordMutation();
            $xfer += $elem109->read($input);
            push(@{$self->{recordMutations}},$elem109);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowMutation');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 2);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutationType}) {
    $xfer += $output->writeFieldBegin('rowMutationType', TType::I32, 4);
    $xfer += $output->writeI32($self->{rowMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordMutations}) {
    $xfer += $output->writeFieldBegin('recordMutations', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recordMutations}}));
      {
        foreach my $iter110 (@{$self->{recordMutations}}) 
        {
          $xfer += ${iter110}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CpuTime;
use base qw(Class::Accessor);
Blur::CpuTime->mk_accessors( qw( cpuTime realTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cpuTime} = undef;
  $self->{realTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CpuTime';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CpuTime');
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 2);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQueryStatus;
use base qw(Class::Accessor);
Blur::BlurQueryStatus->mk_accessors( qw( query cpuTimes completeShards totalShards state uuid status user ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{cpuTimes} = undef;
  $self->{completeShards} = undef;
  $self->{totalShards} = undef;
  $self->{state} = undef;
  $self->{uuid} = undef;
  $self->{status} = undef;
  $self->{user} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{cpuTimes}) {
      $self->{cpuTimes} = $vals->{cpuTimes};
    }
    if (defined $vals->{completeShards}) {
      $self->{completeShards} = $vals->{completeShards};
    }
    if (defined $vals->{totalShards}) {
      $self->{totalShards} = $vals->{totalShards};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{user}) {
      $self->{user} = $vals->{user};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQueryStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size111 = 0;
          $self->{cpuTimes} = {};
          my $_ktype112 = 0;
          my $_vtype113 = 0;
          $xfer += $input->readMapBegin(\$_ktype112, \$_vtype113, \$_size111);
          for (my $_i115 = 0; $_i115 < $_size111; ++$_i115)
          {
            my $key116 = '';
            my $val117 = new Blur::CpuTime();
            $xfer += $input->readString(\$key116);
            $val117 = new Blur::CpuTime();
            $xfer += $val117->read($input);
            $self->{cpuTimes}->{$key116} = $val117;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{completeShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{status});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{user} = new Blur::User();
        $xfer += $self->{user}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQueryStatus');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTimes}) {
    $xfer += $output->writeFieldBegin('cpuTimes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{cpuTimes}}));
      {
        while( my ($kiter118,$viter119) = each %{$self->{cpuTimes}}) 
        {
          $xfer += $output->writeString($kiter118);
          $xfer += ${viter119}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{completeShards}) {
    $xfer += $output->writeFieldBegin('completeShards', TType::I32, 3);
    $xfer += $output->writeI32($self->{completeShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalShards}) {
    $xfer += $output->writeFieldBegin('totalShards', TType::I32, 4);
    $xfer += $output->writeI32($self->{totalShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::STRING, 6);
    $xfer += $output->writeString($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::I32, 7);
    $xfer += $output->writeI32($self->{status});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user}) {
    $xfer += $output->writeFieldBegin('user', TType::STRUCT, 8);
    $xfer += $self->{user}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableStats;
use base qw(Class::Accessor);
Blur::TableStats->mk_accessors( qw( tableName bytes recordCount rowCount segmentImportPendingCount segmentImportInProgressCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{bytes} = undef;
  $self->{recordCount} = undef;
  $self->{rowCount} = undef;
  $self->{segmentImportPendingCount} = 0;
  $self->{segmentImportInProgressCount} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{bytes}) {
      $self->{bytes} = $vals->{bytes};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
    if (defined $vals->{rowCount}) {
      $self->{rowCount} = $vals->{rowCount};
    }
    if (defined $vals->{segmentImportPendingCount}) {
      $self->{segmentImportPendingCount} = $vals->{segmentImportPendingCount};
    }
    if (defined $vals->{segmentImportInProgressCount}) {
      $self->{segmentImportInProgressCount} = $vals->{segmentImportInProgressCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableStats';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{bytes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{segmentImportPendingCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{segmentImportInProgressCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableStats');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bytes}) {
    $xfer += $output->writeFieldBegin('bytes', TType::I64, 2);
    $xfer += $output->writeI64($self->{bytes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I64, 3);
    $xfer += $output->writeI64($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowCount}) {
    $xfer += $output->writeFieldBegin('rowCount', TType::I64, 4);
    $xfer += $output->writeI64($self->{rowCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{segmentImportPendingCount}) {
    $xfer += $output->writeFieldBegin('segmentImportPendingCount', TType::I64, 5);
    $xfer += $output->writeI64($self->{segmentImportPendingCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{segmentImportInProgressCount}) {
    $xfer += $output->writeFieldBegin('segmentImportInProgressCount', TType::I64, 6);
    $xfer += $output->writeI64($self->{segmentImportInProgressCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnDefinition;
use base qw(Class::Accessor);
Blur::ColumnDefinition->mk_accessors( qw( family columnName subColumnName fieldLessIndexed fieldType properties sortable multiValueField ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{columnName} = undef;
  $self->{subColumnName} = undef;
  $self->{fieldLessIndexed} = undef;
  $self->{fieldType} = undef;
  $self->{properties} = undef;
  $self->{sortable} = undef;
  $self->{multiValueField} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{subColumnName}) {
      $self->{subColumnName} = $vals->{subColumnName};
    }
    if (defined $vals->{fieldLessIndexed}) {
      $self->{fieldLessIndexed} = $vals->{fieldLessIndexed};
    }
    if (defined $vals->{fieldType}) {
      $self->{fieldType} = $vals->{fieldType};
    }
    if (defined $vals->{properties}) {
      $self->{properties} = $vals->{properties};
    }
    if (defined $vals->{sortable}) {
      $self->{sortable} = $vals->{sortable};
    }
    if (defined $vals->{multiValueField}) {
      $self->{multiValueField} = $vals->{multiValueField};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subColumnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fieldLessIndexed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fieldType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size120 = 0;
          $self->{properties} = {};
          my $_ktype121 = 0;
          my $_vtype122 = 0;
          $xfer += $input->readMapBegin(\$_ktype121, \$_vtype122, \$_size120);
          for (my $_i124 = 0; $_i124 < $_size120; ++$_i124)
          {
            my $key125 = '';
            my $val126 = '';
            $xfer += $input->readString(\$key125);
            $xfer += $input->readString(\$val126);
            $self->{properties}->{$key125} = $val126;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{sortable});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{multiValueField});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDefinition');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subColumnName}) {
    $xfer += $output->writeFieldBegin('subColumnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{subColumnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fieldLessIndexed}) {
    $xfer += $output->writeFieldBegin('fieldLessIndexed', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{fieldLessIndexed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fieldType}) {
    $xfer += $output->writeFieldBegin('fieldType', TType::STRING, 5);
    $xfer += $output->writeString($self->{fieldType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{properties}) {
    $xfer += $output->writeFieldBegin('properties', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{properties}}));
      {
        while( my ($kiter127,$viter128) = each %{$self->{properties}}) 
        {
          $xfer += $output->writeString($kiter127);
          $xfer += $output->writeString($viter128);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sortable}) {
    $xfer += $output->writeFieldBegin('sortable', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{sortable});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{multiValueField}) {
    $xfer += $output->writeFieldBegin('multiValueField', TType::BOOL, 8);
    $xfer += $output->writeBool($self->{multiValueField});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Schema;
use base qw(Class::Accessor);
Blur::Schema->mk_accessors( qw( table families ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{families} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{families}) {
      $self->{families} = $vals->{families};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size129 = 0;
          $self->{families} = {};
          my $_ktype130 = 0;
          my $_vtype131 = 0;
          $xfer += $input->readMapBegin(\$_ktype130, \$_vtype131, \$_size129);
          for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
          {
            my $key134 = '';
            my $val135 = [];
            $xfer += $input->readString(\$key134);
            {
              my $_size136 = 0;
              $val135 = {};
              my $_ktype137 = 0;
              my $_vtype138 = 0;
              $xfer += $input->readMapBegin(\$_ktype137, \$_vtype138, \$_size136);
              for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
              {
                my $key141 = '';
                my $val142 = new Blur::ColumnDefinition();
                $xfer += $input->readString(\$key141);
                $val142 = new Blur::ColumnDefinition();
                $xfer += $val142->read($input);
                $val135->{$key141} = $val142;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{families}->{$key134} = $val135;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{families}) {
    $xfer += $output->writeFieldBegin('families', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{families}}));
      {
        while( my ($kiter143,$viter144) = each %{$self->{families}}) 
        {
          $xfer += $output->writeString($kiter143);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{${viter144}}));
            {
              while( my ($kiter145,$viter146) = each %{${viter144}}) 
              {
                $xfer += $output->writeString($kiter145);
                $xfer += ${viter146}->write($output);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableDescriptor;
use base qw(Class::Accessor);
Blur::TableDescriptor->mk_accessors( qw( enabled shardCount tableUri cluster name similarityClass blockCaching blockCachingFileTypes readOnly preCacheCols tableProperties strictTypes defaultMissingFieldType defaultMissingFieldLessIndexing defaultMissingFieldProps ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{enabled} = 1;
  $self->{shardCount} = 1;
  $self->{tableUri} = undef;
  $self->{cluster} = "default";
  $self->{name} = undef;
  $self->{similarityClass} = undef;
  $self->{blockCaching} = 1;
  $self->{blockCachingFileTypes} = undef;
  $self->{readOnly} = 0;
  $self->{preCacheCols} = undef;
  $self->{tableProperties} = undef;
  $self->{strictTypes} = 0;
  $self->{defaultMissingFieldType} = "text";
  $self->{defaultMissingFieldLessIndexing} = 1;
  $self->{defaultMissingFieldProps} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{enabled}) {
      $self->{enabled} = $vals->{enabled};
    }
    if (defined $vals->{shardCount}) {
      $self->{shardCount} = $vals->{shardCount};
    }
    if (defined $vals->{tableUri}) {
      $self->{tableUri} = $vals->{tableUri};
    }
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{similarityClass}) {
      $self->{similarityClass} = $vals->{similarityClass};
    }
    if (defined $vals->{blockCaching}) {
      $self->{blockCaching} = $vals->{blockCaching};
    }
    if (defined $vals->{blockCachingFileTypes}) {
      $self->{blockCachingFileTypes} = $vals->{blockCachingFileTypes};
    }
    if (defined $vals->{readOnly}) {
      $self->{readOnly} = $vals->{readOnly};
    }
    if (defined $vals->{preCacheCols}) {
      $self->{preCacheCols} = $vals->{preCacheCols};
    }
    if (defined $vals->{tableProperties}) {
      $self->{tableProperties} = $vals->{tableProperties};
    }
    if (defined $vals->{strictTypes}) {
      $self->{strictTypes} = $vals->{strictTypes};
    }
    if (defined $vals->{defaultMissingFieldType}) {
      $self->{defaultMissingFieldType} = $vals->{defaultMissingFieldType};
    }
    if (defined $vals->{defaultMissingFieldLessIndexing}) {
      $self->{defaultMissingFieldLessIndexing} = $vals->{defaultMissingFieldLessIndexing};
    }
    if (defined $vals->{defaultMissingFieldProps}) {
      $self->{defaultMissingFieldProps} = $vals->{defaultMissingFieldProps};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{enabled});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{shardCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{similarityClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{blockCaching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size147 = 0;
          $self->{blockCachingFileTypes} = {};
          my $_etype150 = 0;
          $xfer += $input->readSetBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            $xfer += $input->readString(\$elem152);
            $self->{blockCachingFileTypes}->{$elem152} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{readOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size153 = 0;
          $self->{preCacheCols} = [];
          my $_etype156 = 0;
          $xfer += $input->readListBegin(\$_etype156, \$_size153);
          for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
          {
            my $elem158 = undef;
            $xfer += $input->readString(\$elem158);
            push(@{$self->{preCacheCols}},$elem158);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size159 = 0;
          $self->{tableProperties} = {};
          my $_ktype160 = 0;
          my $_vtype161 = 0;
          $xfer += $input->readMapBegin(\$_ktype160, \$_vtype161, \$_size159);
          for (my $_i163 = 0; $_i163 < $_size159; ++$_i163)
          {
            my $key164 = '';
            my $val165 = '';
            $xfer += $input->readString(\$key164);
            $xfer += $input->readString(\$val165);
            $self->{tableProperties}->{$key164} = $val165;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{strictTypes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{defaultMissingFieldType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{defaultMissingFieldLessIndexing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size166 = 0;
          $self->{defaultMissingFieldProps} = {};
          my $_ktype167 = 0;
          my $_vtype168 = 0;
          $xfer += $input->readMapBegin(\$_ktype167, \$_vtype168, \$_size166);
          for (my $_i170 = 0; $_i170 < $_size166; ++$_i170)
          {
            my $key171 = '';
            my $val172 = '';
            $xfer += $input->readString(\$key171);
            $xfer += $input->readString(\$val172);
            $self->{defaultMissingFieldProps}->{$key171} = $val172;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableDescriptor');
  if (defined $self->{enabled}) {
    $xfer += $output->writeFieldBegin('enabled', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{enabled});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardCount}) {
    $xfer += $output->writeFieldBegin('shardCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{shardCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableUri}) {
    $xfer += $output->writeFieldBegin('tableUri', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 7);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 8);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{similarityClass}) {
    $xfer += $output->writeFieldBegin('similarityClass', TType::STRING, 9);
    $xfer += $output->writeString($self->{similarityClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCaching}) {
    $xfer += $output->writeFieldBegin('blockCaching', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{blockCaching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCachingFileTypes}) {
    $xfer += $output->writeFieldBegin('blockCachingFileTypes', TType::SET, 11);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{blockCachingFileTypes}}));
      {
        foreach my $iter173 (@{$self->{blockCachingFileTypes}})
        {
          $xfer += $output->writeString($iter173);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{readOnly}) {
    $xfer += $output->writeFieldBegin('readOnly', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{readOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preCacheCols}) {
    $xfer += $output->writeFieldBegin('preCacheCols', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{preCacheCols}}));
      {
        foreach my $iter174 (@{$self->{preCacheCols}}) 
        {
          $xfer += $output->writeString($iter174);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableProperties}) {
    $xfer += $output->writeFieldBegin('tableProperties', TType::MAP, 14);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{tableProperties}}));
      {
        while( my ($kiter175,$viter176) = each %{$self->{tableProperties}}) 
        {
          $xfer += $output->writeString($kiter175);
          $xfer += $output->writeString($viter176);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strictTypes}) {
    $xfer += $output->writeFieldBegin('strictTypes', TType::BOOL, 15);
    $xfer += $output->writeBool($self->{strictTypes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldType}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldType', TType::STRING, 16);
    $xfer += $output->writeString($self->{defaultMissingFieldType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldLessIndexing}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldLessIndexing', TType::BOOL, 17);
    $xfer += $output->writeBool($self->{defaultMissingFieldLessIndexing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldProps}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldProps', TType::MAP, 18);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{defaultMissingFieldProps}}));
      {
        while( my ($kiter177,$viter178) = each %{$self->{defaultMissingFieldProps}}) 
        {
          $xfer += $output->writeString($kiter177);
          $xfer += $output->writeString($viter178);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Metric;
use base qw(Class::Accessor);
Blur::Metric->mk_accessors( qw( name strMap longMap doubleMap ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strMap} = undef;
  $self->{longMap} = undef;
  $self->{doubleMap} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strMap}) {
      $self->{strMap} = $vals->{strMap};
    }
    if (defined $vals->{longMap}) {
      $self->{longMap} = $vals->{longMap};
    }
    if (defined $vals->{doubleMap}) {
      $self->{doubleMap} = $vals->{doubleMap};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Metric';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size179 = 0;
          $self->{strMap} = {};
          my $_ktype180 = 0;
          my $_vtype181 = 0;
          $xfer += $input->readMapBegin(\$_ktype180, \$_vtype181, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $key184 = '';
            my $val185 = '';
            $xfer += $input->readString(\$key184);
            $xfer += $input->readString(\$val185);
            $self->{strMap}->{$key184} = $val185;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size186 = 0;
          $self->{longMap} = {};
          my $_ktype187 = 0;
          my $_vtype188 = 0;
          $xfer += $input->readMapBegin(\$_ktype187, \$_vtype188, \$_size186);
          for (my $_i190 = 0; $_i190 < $_size186; ++$_i190)
          {
            my $key191 = '';
            my $val192 = 0;
            $xfer += $input->readString(\$key191);
            $xfer += $input->readI64(\$val192);
            $self->{longMap}->{$key191} = $val192;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size193 = 0;
          $self->{doubleMap} = {};
          my $_ktype194 = 0;
          my $_vtype195 = 0;
          $xfer += $input->readMapBegin(\$_ktype194, \$_vtype195, \$_size193);
          for (my $_i197 = 0; $_i197 < $_size193; ++$_i197)
          {
            my $key198 = '';
            my $val199 = 0.0;
            $xfer += $input->readString(\$key198);
            $xfer += $input->readDouble(\$val199);
            $self->{doubleMap}->{$key198} = $val199;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Metric');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strMap}) {
    $xfer += $output->writeFieldBegin('strMap', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{strMap}}));
      {
        while( my ($kiter200,$viter201) = each %{$self->{strMap}}) 
        {
          $xfer += $output->writeString($kiter200);
          $xfer += $output->writeString($viter201);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{longMap}) {
    $xfer += $output->writeFieldBegin('longMap', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{longMap}}));
      {
        while( my ($kiter202,$viter203) = each %{$self->{longMap}}) 
        {
          $xfer += $output->writeString($kiter202);
          $xfer += $output->writeI64($viter203);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleMap}) {
    $xfer += $output->writeFieldBegin('doubleMap', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{doubleMap}}));
      {
        while( my ($kiter204,$viter205) = each %{$self->{doubleMap}}) 
        {
          $xfer += $output->writeString($kiter204);
          $xfer += $output->writeDouble($viter205);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Value;
use base qw(Class::Accessor);
Blur::Value->mk_accessors( qw( stringValue intValue shortValue longValue doubleValue floatValue binaryValue booleanValue nullValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{stringValue} = undef;
  $self->{intValue} = undef;
  $self->{shortValue} = undef;
  $self->{longValue} = undef;
  $self->{doubleValue} = undef;
  $self->{floatValue} = undef;
  $self->{binaryValue} = undef;
  $self->{booleanValue} = undef;
  $self->{nullValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{stringValue}) {
      $self->{stringValue} = $vals->{stringValue};
    }
    if (defined $vals->{intValue}) {
      $self->{intValue} = $vals->{intValue};
    }
    if (defined $vals->{shortValue}) {
      $self->{shortValue} = $vals->{shortValue};
    }
    if (defined $vals->{longValue}) {
      $self->{longValue} = $vals->{longValue};
    }
    if (defined $vals->{doubleValue}) {
      $self->{doubleValue} = $vals->{doubleValue};
    }
    if (defined $vals->{floatValue}) {
      $self->{floatValue} = $vals->{floatValue};
    }
    if (defined $vals->{binaryValue}) {
      $self->{binaryValue} = $vals->{binaryValue};
    }
    if (defined $vals->{booleanValue}) {
      $self->{booleanValue} = $vals->{booleanValue};
    }
    if (defined $vals->{nullValue}) {
      $self->{nullValue} = $vals->{nullValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Value';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stringValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{intValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{shortValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{longValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{doubleValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{floatValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{binaryValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{booleanValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{nullValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Value');
  if (defined $self->{stringValue}) {
    $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 1);
    $xfer += $output->writeString($self->{stringValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{intValue}) {
    $xfer += $output->writeFieldBegin('intValue', TType::I32, 2);
    $xfer += $output->writeI32($self->{intValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shortValue}) {
    $xfer += $output->writeFieldBegin('shortValue', TType::I16, 3);
    $xfer += $output->writeI16($self->{shortValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{longValue}) {
    $xfer += $output->writeFieldBegin('longValue', TType::I64, 4);
    $xfer += $output->writeI64($self->{longValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleValue}) {
    $xfer += $output->writeFieldBegin('doubleValue', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{doubleValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{floatValue}) {
    $xfer += $output->writeFieldBegin('floatValue', TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{floatValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{binaryValue}) {
    $xfer += $output->writeFieldBegin('binaryValue', TType::STRING, 7);
    $xfer += $output->writeString($self->{binaryValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{booleanValue}) {
    $xfer += $output->writeFieldBegin('booleanValue', TType::BOOL, 8);
    $xfer += $output->writeBool($self->{booleanValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nullValue}) {
    $xfer += $output->writeFieldBegin('nullValue', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{nullValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Shard;
use base qw(Class::Accessor);
Blur::Shard->mk_accessors( qw( table shard ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{shard} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{shard}) {
      $self->{shard} = $vals->{shard};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Shard';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{shard});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Shard');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shard}) {
    $xfer += $output->writeFieldBegin('shard', TType::STRING, 2);
    $xfer += $output->writeString($self->{shard});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Server;
use base qw(Class::Accessor);
Blur::Server->mk_accessors( qw( server ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{server} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{server}) {
      $self->{server} = $vals->{server};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Server';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{server});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Server');
  if (defined $self->{server}) {
    $xfer += $output->writeFieldBegin('server', TType::STRING, 1);
    $xfer += $output->writeString($self->{server});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurPackedObject;
use base qw(Class::Accessor);
Blur::BlurPackedObject->mk_accessors( qw( parentId type value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{parentId} = undef;
  $self->{type} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{parentId}) {
      $self->{parentId} = $vals->{parentId};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurPackedObject';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{parentId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{value} = new Blur::Value();
        $xfer += $self->{value}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurPackedObject');
  if (defined $self->{parentId}) {
    $xfer += $output->writeFieldBegin('parentId', TType::I32, 1);
    $xfer += $output->writeI32($self->{parentId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 2);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRUCT, 3);
    $xfer += $self->{value}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ValueObject;
use base qw(Class::Accessor);
Blur::ValueObject->mk_accessors( qw( value blurObject ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  $self->{blurObject} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{blurObject}) {
      $self->{blurObject} = $vals->{blurObject};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ValueObject';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{value} = new Blur::Value();
        $xfer += $self->{value}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size206 = 0;
          $self->{blurObject} = [];
          my $_etype209 = 0;
          $xfer += $input->readListBegin(\$_etype209, \$_size206);
          for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
          {
            my $elem211 = undef;
            $elem211 = new Blur::BlurPackedObject();
            $xfer += $elem211->read($input);
            push(@{$self->{blurObject}},$elem211);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ValueObject');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRUCT, 1);
    $xfer += $self->{value}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blurObject}) {
    $xfer += $output->writeFieldBegin('blurObject', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{blurObject}}));
      {
        foreach my $iter212 (@{$self->{blurObject}}) 
        {
          $xfer += ${iter212}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Response;
use base qw(Class::Accessor);
Blur::Response->mk_accessors( qw( shardToValue serverToValue value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{shardToValue} = undef;
  $self->{serverToValue} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{shardToValue}) {
      $self->{shardToValue} = $vals->{shardToValue};
    }
    if (defined $vals->{serverToValue}) {
      $self->{serverToValue} = $vals->{serverToValue};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Response';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size213 = 0;
          $self->{shardToValue} = {};
          my $_ktype214 = 0;
          my $_vtype215 = 0;
          $xfer += $input->readMapBegin(\$_ktype214, \$_vtype215, \$_size213);
          for (my $_i217 = 0; $_i217 < $_size213; ++$_i217)
          {
            my $key218 = new Blur::Shard();
            my $val219 = new Blur::ValueObject();
            $key218 = new Blur::Shard();
            $xfer += $key218->read($input);
            $val219 = new Blur::ValueObject();
            $xfer += $val219->read($input);
            $self->{shardToValue}->{$key218} = $val219;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size220 = 0;
          $self->{serverToValue} = {};
          my $_ktype221 = 0;
          my $_vtype222 = 0;
          $xfer += $input->readMapBegin(\$_ktype221, \$_vtype222, \$_size220);
          for (my $_i224 = 0; $_i224 < $_size220; ++$_i224)
          {
            my $key225 = new Blur::Server();
            my $val226 = new Blur::ValueObject();
            $key225 = new Blur::Server();
            $xfer += $key225->read($input);
            $val226 = new Blur::ValueObject();
            $xfer += $val226->read($input);
            $self->{serverToValue}->{$key225} = $val226;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{value} = new Blur::ValueObject();
        $xfer += $self->{value}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Response');
  if (defined $self->{shardToValue}) {
    $xfer += $output->writeFieldBegin('shardToValue', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRUCT, TType::STRUCT, scalar(keys %{$self->{shardToValue}}));
      {
        while( my ($kiter227,$viter228) = each %{$self->{shardToValue}}) 
        {
          $xfer += ${kiter227}->write($output);
          $xfer += ${viter228}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serverToValue}) {
    $xfer += $output->writeFieldBegin('serverToValue', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRUCT, TType::STRUCT, scalar(keys %{$self->{serverToValue}}));
      {
        while( my ($kiter229,$viter230) = each %{$self->{serverToValue}}) 
        {
          $xfer += ${kiter229}->write($output);
          $xfer += ${viter230}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRUCT, 3);
    $xfer += $self->{value}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Arguments;
use base qw(Class::Accessor);
Blur::Arguments->mk_accessors( qw( values ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{values} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Arguments';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size231 = 0;
          $self->{values} = {};
          my $_ktype232 = 0;
          my $_vtype233 = 0;
          $xfer += $input->readMapBegin(\$_ktype232, \$_vtype233, \$_size231);
          for (my $_i235 = 0; $_i235 < $_size231; ++$_i235)
          {
            my $key236 = '';
            my $val237 = new Blur::ValueObject();
            $xfer += $input->readString(\$key236);
            $val237 = new Blur::ValueObject();
            $xfer += $val237->read($input);
            $self->{values}->{$key236} = $val237;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Arguments');
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{values}}));
      {
        while( my ($kiter238,$viter239) = each %{$self->{values}}) 
        {
          $xfer += $output->writeString($kiter238);
          $xfer += ${viter239}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CommandStatus;
use base qw(Class::Accessor);
Blur::CommandStatus->mk_accessors( qw( executionId table commandName arguments state ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{executionId} = undef;
  $self->{table} = undef;
  $self->{commandName} = undef;
  $self->{arguments} = undef;
  $self->{state} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{executionId}) {
      $self->{executionId} = $vals->{executionId};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{commandName}) {
      $self->{commandName} = $vals->{commandName};
    }
    if (defined $vals->{arguments}) {
      $self->{arguments} = $vals->{arguments};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CommandStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{executionId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{commandName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{arguments} = new Blur::Arguments();
        $xfer += $self->{arguments}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CommandStatus');
  if (defined $self->{executionId}) {
    $xfer += $output->writeFieldBegin('executionId', TType::STRING, 1);
    $xfer += $output->writeString($self->{executionId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 2);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{commandName}) {
    $xfer += $output->writeFieldBegin('commandName', TType::STRING, 3);
    $xfer += $output->writeString($self->{commandName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arguments}) {
    $xfer += $output->writeFieldBegin('arguments', TType::STRUCT, 4);
    $xfer += $self->{arguments}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ArgumentDescriptor;
use base qw(Class::Accessor);
Blur::ArgumentDescriptor->mk_accessors( qw( name type description ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{type} = undef;
  $self->{description} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ArgumentDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ArgumentDescriptor');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 3);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CommandDescriptor;
use base qw(Class::Accessor);
Blur::CommandDescriptor->mk_accessors( qw( commandName description requiredArguments optionalArguments returnType version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{commandName} = undef;
  $self->{description} = undef;
  $self->{requiredArguments} = undef;
  $self->{optionalArguments} = undef;
  $self->{returnType} = undef;
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{commandName}) {
      $self->{commandName} = $vals->{commandName};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{requiredArguments}) {
      $self->{requiredArguments} = $vals->{requiredArguments};
    }
    if (defined $vals->{optionalArguments}) {
      $self->{optionalArguments} = $vals->{optionalArguments};
    }
    if (defined $vals->{returnType}) {
      $self->{returnType} = $vals->{returnType};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CommandDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{commandName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size240 = 0;
          $self->{requiredArguments} = {};
          my $_ktype241 = 0;
          my $_vtype242 = 0;
          $xfer += $input->readMapBegin(\$_ktype241, \$_vtype242, \$_size240);
          for (my $_i244 = 0; $_i244 < $_size240; ++$_i244)
          {
            my $key245 = '';
            my $val246 = new Blur::ArgumentDescriptor();
            $xfer += $input->readString(\$key245);
            $val246 = new Blur::ArgumentDescriptor();
            $xfer += $val246->read($input);
            $self->{requiredArguments}->{$key245} = $val246;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size247 = 0;
          $self->{optionalArguments} = {};
          my $_ktype248 = 0;
          my $_vtype249 = 0;
          $xfer += $input->readMapBegin(\$_ktype248, \$_vtype249, \$_size247);
          for (my $_i251 = 0; $_i251 < $_size247; ++$_i251)
          {
            my $key252 = '';
            my $val253 = new Blur::ArgumentDescriptor();
            $xfer += $input->readString(\$key252);
            $val253 = new Blur::ArgumentDescriptor();
            $xfer += $val253->read($input);
            $self->{optionalArguments}->{$key252} = $val253;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{returnType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CommandDescriptor');
  if (defined $self->{commandName}) {
    $xfer += $output->writeFieldBegin('commandName', TType::STRING, 1);
    $xfer += $output->writeString($self->{commandName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{requiredArguments}) {
    $xfer += $output->writeFieldBegin('requiredArguments', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{requiredArguments}}));
      {
        while( my ($kiter254,$viter255) = each %{$self->{requiredArguments}}) 
        {
          $xfer += $output->writeString($kiter254);
          $xfer += ${viter255}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{optionalArguments}) {
    $xfer += $output->writeFieldBegin('optionalArguments', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{optionalArguments}}));
      {
        while( my ($kiter256,$viter257) = each %{$self->{optionalArguments}}) 
        {
          $xfer += $output->writeString($kiter256);
          $xfer += ${viter257}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{returnType}) {
    $xfer += $output->writeFieldBegin('returnType', TType::STRING, 5);
    $xfer += $output->writeString($self->{returnType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 6);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
